<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>图-最短路径之Dijkstra算法</title>
    <link href="/posts/5735/"/>
    <url>/posts/5735/</url>
    
    <content type="html"><![CDATA[<p>Dijkstra算法是解决<strong>单源点最短路径</strong>问题的一种<strong>贪心算法</strong>，每次向集合中加入一个最短路径的长度最小的节点，直到所有节点均加入集合。Dijkstra算法不能用于<strong>边权为负</strong>的情况。</p><p>假设T表示已经找到最短路径的节点集合，初始时，T为空集。</p><ol type="1"><li>选择一个节点作为源点。</li><li>从集合T之外的节点中选择一个节点u，使得源点到节点u的距离最小，即节点u的最短路径的长度最小，将节点u加入集合T。</li><li>更新节点u的所有未加入集合T的邻接节点的最短路径长度。</li><li>重复步骤2和3，直到所有节点加入集合。</li></ol><p>注意：</p><ol type="1"><li>在步骤2中，比较源点到每一个节点（集合T之外）的距离，对于距离最小的节点，当前的路径一定是最短路径。</li><li>Dijkstra算法与<strong>Prim算法</strong>的实现思路基本相同，不同之处在于<code>dist</code>数组的含义。Prim算法中<code>dist</code>数组表示集合T到节点的距离，而在Dijkstra算法中则表示源点到节点的距离。除此之外，更新邻接节点的操作也不同。</li></ol><p>基于邻接矩阵的代码如下： <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> Dijkstra &#123;<br>    <span class="hljs-type">int</span>[][] matrix;<br>    <span class="hljs-type">int</span> V;<br><br>    <span class="hljs-built_in">public</span> Dijkstra(<span class="hljs-type">int</span> V)&#123;<br>        this.V = V;<br>        matrix = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[V][V];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; V; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; V; j++)&#123;<br>                matrix[i][j] = <span class="hljs-type">Integer</span>.MAX_VALUE;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> addEdge(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> weight)&#123;<br>        matrix[i][j] = weight;<br>        matrix[j][i] = weight; //有向图需要删掉这一行<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> dijkstra(<span class="hljs-type">int</span> init)&#123;<br>        <span class="hljs-type">boolean</span>[] visited = <span class="hljs-built_in">new</span> <span class="hljs-type">boolean</span>[V]; //表示节点是否加入集合T<br>        <span class="hljs-type">int</span>[] parent = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[V]; //表示节点的父节点<br>        <span class="hljs-type">int</span>[] dist = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span> [V]; //表示源点到节点i的距离<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; V; i++)&#123;<br>            parent[i] = i;<br>            dist[i] = <span class="hljs-type">Integer</span>.MAX_VALUE;<br>            visited[i] = <span class="hljs-keyword">false</span>;<br>        &#125;<br>        dist[init] = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; V; i++)&#123;<br>            //获得从起始节点到其余未访问节点中距离最小的一个<br>            <span class="hljs-type">int</span> next = <span class="hljs-number">-1</span>; <br>            <span class="hljs-type">int</span> <span class="hljs-keyword">minValue</span> = Integer.MAX_VALUE;<br>            for(int j = <span class="hljs-number">0</span>; j &lt; V; j++)&#123;<br>                <span class="hljs-keyword">if</span>(!visited[j] &amp;&amp; dist[j] &lt;= <span class="hljs-keyword">minValue</span>)&#123;<br>                    <span class="hljs-keyword">minValue</span> = dist[j];<br>                    next = j;<br>                &#125;<br>            &#125;<br>            visited[next] = true;<br><br>            //更新邻接节点的最短路径长度<br>            for(int j = <span class="hljs-number">0</span>; j &lt; V; j++)&#123;<br>                <span class="hljs-keyword">if</span>(visited[j] || matrix[next][j] == <span class="hljs-type">Integer</span>.MAX_VALUE || dist[next] == <span class="hljs-type">Integer</span>.MAX_VALUE)&#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(dist[next] + matrix[next][j] &lt; dist[j])&#123;<br>                    dist[j] = dist[next] + matrix[next][j];<br>                    parent[j] = next;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; V; i++)&#123;<br>            String str = String.format(&quot;%s -&gt; %s: &quot;, init, i);<br>            <span class="hljs-keyword">if</span>(init == i || dist[i] == <span class="hljs-type">Integer</span>.MAX_VALUE)&#123;<br>                <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(str + &quot;不存在路径&quot;);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            str += getPath(parent, i);<br>            <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(str);<br>            <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;距离为：&quot; + dist[i]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> String getPath(<span class="hljs-type">int</span>[] parent, <span class="hljs-type">int</span> v)&#123;<br>        String tmp = &quot;&quot;;<br>        <span class="hljs-keyword">if</span>(parent[v] == v)&#123;<br>            tmp += v + &quot; &quot;;<br>        &#125;<br>        <span class="hljs-keyword">else</span> tmp += getPath(parent, parent[v]) + v + &quot; &quot;;<br>        <span class="hljs-keyword">return</span> tmp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>基于邻接矩阵的Dijkstra算法的时间复杂度为<spanclass="math inline">\(O(V^2)\)</span>，可以使用邻接表和优先队列进行优化，使时间复杂度变为<spanclass="math inline">\(O(ElogV)\)</span>，这一部分的详细分析可以看Prim算法那篇文章。</p><p>代码如下： <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> DijkstraHeap &#123;<br>    static <span class="hljs-keyword">class</span> Pair&#123;<br>        <span class="hljs-type">int</span> dest;<br>        <span class="hljs-type">int</span> weight;<br>        <span class="hljs-built_in">public</span> Pair(<span class="hljs-type">int</span> dest, <span class="hljs-type">int</span> weight)&#123;<br>            this.dest = dest;<br>            this.weight = weight;<br>        &#125;<br>    &#125;<br><br>    List&lt;List&lt;Pair&gt;&gt; adjList;<br>    <span class="hljs-type">int</span> V;<br><br>    <span class="hljs-built_in">public</span> DijkstraHeap(<span class="hljs-type">int</span> V)&#123;<br>        this.V = V;<br>        adjList = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; V; i++)&#123;<br>            adjList.<span class="hljs-keyword">add</span>(<span class="hljs-built_in">new</span> ArrayList&lt;&gt;());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> addEdge(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> weight)&#123;<br>        adjList.<span class="hljs-keyword">get</span>(i).<span class="hljs-keyword">add</span>(<span class="hljs-built_in">new</span> Pair(j, weight));<br>        adjList.<span class="hljs-keyword">get</span>(j).<span class="hljs-keyword">add</span>(<span class="hljs-built_in">new</span> Pair(i, weight)); //有向图需要删除这一行<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> dijkstra(<span class="hljs-type">int</span> init)&#123;<br>        Comparator&lt;Pair&gt; cmp = <span class="hljs-built_in">new</span> Comparator&lt;Pair&gt;() &#123;<br>            <span class="hljs-built_in">public</span> <span class="hljs-type">int</span> compare(Pair p1, Pair p2)&#123;<br>                <span class="hljs-keyword">return</span> p1.weight - p2.weight;<br>            &#125;<br>        &#125;;<br>        PriorityQueue&lt;Pair&gt; pQueue = <span class="hljs-built_in">new</span> PriorityQueue&lt;&gt;(cmp); <br>        <span class="hljs-type">boolean</span>[] visited = <span class="hljs-built_in">new</span> <span class="hljs-type">boolean</span>[V]; //表示节点是否加入集合T<br>        <span class="hljs-type">int</span>[] parent = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[V]; //表示节点的父节点<br>        <span class="hljs-type">int</span>[] dist = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span> [V]; //表示源点到节点i的距离<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; V; i++)&#123;<br>            parent[i] = i;<br>            dist[i] = <span class="hljs-type">Integer</span>.MAX_VALUE;<br>            visited[i] = <span class="hljs-keyword">false</span>;<br>        &#125;<br>        dist[init] = <span class="hljs-number">0</span>;<br>        pQueue.offer(<span class="hljs-built_in">new</span> Pair(init, dist[init]));<br><br>        <span class="hljs-keyword">while</span>(!pQueue.isEmpty())&#123;<br>            Pair p = pQueue.poll();<br>            <span class="hljs-type">int</span> next = p.dest;<br><br>            <span class="hljs-keyword">if</span>(visited[next])&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            visited[next] = <span class="hljs-keyword">true</span>;<br>            <span class="hljs-keyword">for</span>(Pair node: adjList.<span class="hljs-keyword">get</span>(next))&#123;<br>                <span class="hljs-type">int</span> v = node.dest;<br>                <span class="hljs-type">int</span> weight = node.weight;<br>                <span class="hljs-keyword">if</span>(dist[next] != <span class="hljs-type">Integer</span>.MAX_VALUE &amp;&amp; dist[next] + weight &lt; dist[v])&#123;<br>                    dist[v] = dist[next] + weight;<br>                    pQueue.offer(<span class="hljs-built_in">new</span> Pair(v, dist[v])); //注意这一行<br>                    parent[v] = next;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; V; i++)&#123;<br>            String str = String.format(&quot;%s -&gt; %s: &quot;, init, i);<br>            <span class="hljs-keyword">if</span>(init == i || dist[i] == <span class="hljs-type">Integer</span>.MAX_VALUE)&#123;<br>                <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(str + &quot;不存在路径&quot;);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            str += getPath(parent, i);<br>            <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(str);<br>            <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;距离为：&quot; + dist[i]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> String getPath(<span class="hljs-type">int</span>[] parent, <span class="hljs-type">int</span> v)&#123;<br>        String tmp = &quot;&quot;;<br>        <span class="hljs-keyword">if</span>(parent[v] == v)&#123;<br>            tmp += v + &quot; &quot;;<br>        &#125;<br>        <span class="hljs-keyword">else</span> tmp += getPath(parent, parent[v]) + v + &quot; &quot;;<br>        <span class="hljs-keyword">return</span> tmp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>图-最短路径之Floyd-Warshall算法</title>
    <link href="/posts/37942/"/>
    <url>/posts/37942/</url>
    
    <content type="html"><![CDATA[<p>Floyd-Warshall算法是解决带权图中<strong>多源最短路径</strong>问题的一种算法，它能够得到图中任意两个节点的最短路径。Floyd-Warshall算法采用了<strong>动态规划</strong>的思想，可以适用于<strong>边权为负</strong>的情况，但是图中不能存在负环。</p><p>算法思想：对于节点i和j的最短路径，如果存在一个中间节点k，使得i经由k到j的路径存在，并且该路径长度小于原来的路径长度，则将节点i和j的最短路径更新为这条路径。需要让图中的每一个节点分别作为中间节点，执行上述判断和更新操作。</p><p>假设<spanclass="math inline">\(dist[k][i][j]\)</span>表示节点i到节点j的最短路径长度，并且该路径的中间节点的范围为<spanclass="math inline">\(\{0, 1, ...,k\}\)</span>，则<strong>状态转移方程</strong>为 <spanclass="math display">\[dist[k][i][j] = min\{dist[k-1][i][j], dist[k-1][i][k] +dist[k-1][k][j]\}\]</span></p><p>对于<spanclass="math inline">\(dist[k][i][k]\)</span>，由于节点k为路径的终点，则节点i到节点k的路径的中间节点必然不包含k，因此<spanclass="math inline">\(dist[k][i][k] =dist[k-1][i][k]\)</span>，同理可得<spanclass="math inline">\(dist[k][k][j] = dist[k-1][k][j]\)</span></p><p>因此上述状态转移方程的第一维可以删除，化简为 <spanclass="math display">\[dist[i][j] = min\{dist[i][j], dist[i][k] + dist[k][j]\}\]</span></p><p>为了记录节点之间的最短路径，还需要使用一个<code>path</code>数组，它记录节点i到j的最短路径的中间节点。如果节点i和j之间不存在最短路径，则用-1表示；如果节点i和j直接相连，则值为j。由于一条路径中可能存在多个中间节点，因此在更新时需要让中间节点的值等于节点i到k的中间节点的值，而不是直接等于k，即<em>找到最靠近起点的中间节点</em>。</p><p>实现代码如下： <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">class</span> FloydWarshall&#123;<br>    <span class="hljs-type">int</span>[][] matrix;<br>    <span class="hljs-type">int</span> V;<br><br>    <span class="hljs-built_in">public</span> FloydWarshall(<span class="hljs-type">int</span> V)&#123;<br>        this.V = V;<br>        matrix = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[V][V];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; V; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; V; j++)&#123;<br>                matrix[i][j] = <span class="hljs-type">Integer</span>.MAX_VALUE;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> addEdge(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> weight)&#123;<br>        matrix[i][j] = weight;<br>        matrix[j][i] = weight; //有向图可以删除这一行<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> floydWarshall()&#123;<br>        <span class="hljs-type">int</span>[][] dist = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[V][V]; // 记录从节点i到节点j的最短路径的距离<br>        <span class="hljs-type">int</span>[][] <span class="hljs-type">path</span> = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[V][V]; // 记录从节点i到节点j的路径的中间节点<br>        //如果i和j不连通，则值为<span class="hljs-number">-1</span>；如果i和j直接相连，则值为j<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; V; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; V; j++)&#123;<br>                <span class="hljs-keyword">if</span>(i == j)&#123;<br>                    dist[i][j] = <span class="hljs-number">0</span>;<br>                    <span class="hljs-type">path</span>[i][j] = <span class="hljs-number">-1</span>; <br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    dist[i][j] = matrix[i][j];<br>                    <span class="hljs-keyword">if</span>(matrix[i][j] != <span class="hljs-type">Integer</span>.MAX_VALUE)&#123;<br>                        <span class="hljs-type">path</span>[i][j] = j;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-type">path</span>[i][j] = <span class="hljs-number">-1</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; V; k++)&#123;<br>            //以节点k作为中间节点<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; V; i++)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; V; j++)&#123;<br>                    <span class="hljs-keyword">if</span>(dist[i][k] == <span class="hljs-type">Integer</span>.MAX_VALUE || dist[k][j] == <span class="hljs-type">Integer</span>.MAX_VALUE)&#123;<br>                        <span class="hljs-keyword">continue</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span>(dist[i][k] + dist[k][j] &lt; dist[i][j])&#123;<br>                        dist[i][j] = dist[i][k] + dist[k][j];<br>                        <span class="hljs-type">path</span>[i][j] = <span class="hljs-type">path</span>[i][k]; //最靠近i的中间节点<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        //显示所有的路径<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; V; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; V; j++)&#123;<br>                String str = String.format(&quot;%s -&gt; %s: &quot;, i, j);<br>                <span class="hljs-keyword">if</span>(dist[i][j] == <span class="hljs-type">Integer</span>.MAX_VALUE || i == j)&#123;<br>                    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(str + &quot;不存在&quot;);<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                str += i + &quot; &quot; + getPath(<span class="hljs-type">path</span>, i, j);<br>                <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(str);<br>                <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;路径长度为:&quot; + dist[i][j]);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> String getPath(<span class="hljs-type">int</span>[][] <span class="hljs-type">path</span>, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)&#123;<br>        String tmp = &quot;&quot;;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-type">path</span>[i][j] != <span class="hljs-number">-1</span>)&#123;<br>            <span class="hljs-type">int</span> k = <span class="hljs-type">path</span>[i][j];<br>            tmp += k + &quot; &quot; + getPath(<span class="hljs-type">path</span>, k, j);<br>        &#125;<br>        <span class="hljs-keyword">return</span> tmp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>Floyd-Warshall算法的时间复杂度为<spanclass="math inline">\(O(V^3)\)</span>，空间复杂度为<spanclass="math inline">\(O(V^2)\)</span>。</p><p>参考资料：</p><ol type="1"><li><ahref="https://leetcode.cn/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/solutions/2525946/dai-ni-fa-ming-floyd-suan-fa-cong-ji-yi-m8s51/">带你发明Floyd 算法：从记忆化搜索到递推（Python/Java/C++/Go/JS/Rust）</a></li><li><ahref="https://www.geeksforgeeks.org/finding-shortest-path-between-any-two-nodes-using-floyd-warshall-algorithm/?ref=gcse_ind">Findingshortest path between any two nodes using Floyd WarshallAlgorithm</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>图-最小生成树之Prim算法</title>
    <link href="/posts/38857/"/>
    <url>/posts/38857/</url>
    
    <content type="html"><![CDATA[<h2 id="基本思想">基本思想</h2><p>与Krusakl算法类似，Prim算法也是一种用于解决最小生成树问题的<strong>贪心算法</strong>。与Kruskal算法不同的地方在于，它每一轮向最小生成树集合中加入一个节点，直到所有节点全部加入集合，也称为<strong>加点法</strong>。</p><p>假设图G = (V,E)，T表示最小生成树集合。初始时T为空集，每个节点到T的距离为无穷大。</p><ol type="1"><li>选定一个节点作为初始节点，将该节点到集合T的距离修改为0。</li><li>从尚未加入集合T的所有节点中找出到集合T的距离最小的节点u，将节点u加入集合T。</li><li>更新节点u的邻接节点到集合T的距离，<em>注意只更新尚未加入集合T的邻接节点</em>。</li><li>重复步骤2和3，直到所有节点全部加入集合T。</li></ol><p>在具体实现中，使用<code>visited</code>数组表示节点是否加入集合T，<code>dist</code>数组保存每一个节点到集合T的距离。在更新节点u的邻接节点到集合T的距离时，需要判断节点u与其邻接节点v所构成的边e的权值是否小于节点v到集合T的距离<code>dist[v]</code>。如果e的权值小于<code>dist[v]</code>，则需要更新<code>dist[v]</code>，并且修改v的父指针指向u。</p><p>基于邻接矩阵的实现代码如下： <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">class</span> PrimMST&#123;<br>    <span class="hljs-type">int</span> V;<br>    <span class="hljs-type">int</span>[][] matrix;<br>    <span class="hljs-type">int</span>[] dist;     // 保存节点到集合T的距离<br>    <span class="hljs-type">int</span>[] parent;   // 保存节点的父节点下标<br>    <span class="hljs-type">boolean</span>[] visited; //是否已经添加到集合中<br><br>    <span class="hljs-built_in">public</span> PrimMST(<span class="hljs-type">int</span> V)&#123;<br>        this.V = V;<br>        matrix = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[V][V];<br>        dist = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[V];<br>        parent = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[V];<br>        visited = <span class="hljs-built_in">new</span> <span class="hljs-type">boolean</span>[V];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; V; i++)&#123;<br>            dist[i] = <span class="hljs-type">Integer</span>.MAX_VALUE;<br>            parent[i] = i;<br>            visited[i] = <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> addEdge(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> weight)&#123;<br>        matrix[i][j] = weight;<br>        matrix[j][i] = weight;<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> prim()&#123;<br>        dist[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; V; i++)&#123;<br>            <span class="hljs-type">int</span> next = getNext(); //获得到集合T的距离最小的节点<br>            visited[next] = <span class="hljs-keyword">true</span>;<br>            <br>            //更新邻接节点到集合T的距离<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; V; j++)&#123;<br>                <span class="hljs-keyword">if</span>(!visited[j] &amp;&amp; matrix[next][j] != <span class="hljs-number">0</span> &amp;&amp; matrix[next][j] &lt; dist[j])&#123;<br>                    dist[j] = matrix[next][j];<br>                    parent[j] = next;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-keyword">cost</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; V; i++)&#123;<br>            String str = String.format(&quot;[%s, %s, %s]&quot;, i, parent[i], matrix[i][parent[i]]);<br>            <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(str);<br>            <span class="hljs-keyword">cost</span> += matrix[i][parent[i]];<br>        &#125;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;总成本为：&quot; + <span class="hljs-keyword">cost</span>);<br>    &#125;<br><br>    //获得到集合T的距离最小的节点<br>    private <span class="hljs-type">int</span> getNext()&#123;<br>        <span class="hljs-type">int</span> next = <span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-keyword">minValue</span> = Integer.MAX_VALUE;<br>        for(int i = <span class="hljs-number">0</span>; i &lt; V; i++)&#123;<br>            <span class="hljs-keyword">if</span>(!visited[i] &amp;&amp; dist[i] &lt; <span class="hljs-keyword">minValue</span>)&#123;<br>                next = i;<br>                <span class="hljs-keyword">minValue</span> = dist[i];<br>            &#125;<br>        &#125;<br>        return next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>设V表示节点数目，E表示边数目。每一轮选择到集合T的距离最小的节点，都需要遍历邻接矩阵的某一行，而更新邻接节点到集合T的距离同理，其时间复杂度均为<spanclass="math inline">\(O(V)\)</span>，总共需要V轮。因此基于邻接矩阵的Prim算法的总时间复杂度为<spanclass="math inline">\(O(V^2)\)</span>。</p><h2 id="算法优化">算法优化</h2><p>使用邻接表和优先队列可以显著降低时间复杂度，提高Prim算法的执行效率。</p><blockquote><p>对于简单无向连通图，其边数E和节点数V满足关系：<spanclass="math inline">\(V-1 &lt;= E &lt;= (V-1)V /2\)</span>。当一个图是稀疏图时，满足<span class="math inline">\(E =O(V)\)</span>；当一个图是稠密图时，满足<span class="math inline">\(E =O(V^2)\)</span>。</p></blockquote><p>与基于邻接矩阵的实现不同，图的存储结构采用邻接表，同时使用优先队列进行查找。由于每一轮中并不会删除上一轮插入的所有边，因此优先队列的插入和删除操作的时间复杂度均为<spanclass="math inline">\(O(logE)\)</span>，更新邻接节点到集合T的距离的总次数为E次，总的时间复杂度为<spanclass="math inline">\(O(ElogE)\)</span>，即<spanclass="math inline">\(O(ElogV)\)</span>。</p><p>基于邻接表和优先队列的代码如下： <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> PrimHeap &#123;<br>    static <span class="hljs-keyword">class</span> Pair&#123;<br>        <span class="hljs-type">int</span> dest;<br>        <span class="hljs-type">int</span> weight;<br><br>        <span class="hljs-built_in">public</span> Pair(<span class="hljs-type">int</span> dest, <span class="hljs-type">int</span> weight)&#123;<br>            this.dest = dest;<br>            this.weight = weight;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">int</span> V;<br>    List&lt;List&lt;Pair&gt;&gt; adjacentlist; //邻接表<br>    <span class="hljs-type">int</span>[] dist;<br>    <span class="hljs-type">boolean</span>[] visited;<br>    <span class="hljs-type">int</span>[] parent;<br><br><br>    <span class="hljs-built_in">public</span> PrimHeap(<span class="hljs-type">int</span> V)&#123;<br>        this.V = V;<br>        dist = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[V];<br>        visited = <span class="hljs-built_in">new</span> <span class="hljs-type">boolean</span>[V];<br>        parent = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[V];<br>        adjacentlist = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;(V);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; V; i++)&#123;<br>            dist[i] = <span class="hljs-type">Integer</span>.MAX_VALUE;<br>            visited[i] = <span class="hljs-keyword">false</span>;<br>            parent[i] = i;<br>            adjacentlist.<span class="hljs-keyword">add</span>(<span class="hljs-built_in">new</span> ArrayList&lt;&gt;());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> addEdge(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> weight)&#123;<br>        adjacentlist.<span class="hljs-keyword">get</span>(i).<span class="hljs-keyword">add</span>(<span class="hljs-built_in">new</span> Pair(j, weight));<br>        adjacentlist.<span class="hljs-keyword">get</span>(j).<span class="hljs-keyword">add</span>(<span class="hljs-built_in">new</span> Pair(i, weight));<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> prim()&#123;<br>        Comparator&lt;Pair&gt; cmp = <span class="hljs-built_in">new</span> Comparator&lt;Pair&gt;() &#123; <br>            <span class="hljs-built_in">public</span> <span class="hljs-type">int</span> compare(Pair p1, Pair p2)&#123;<br>                <span class="hljs-keyword">return</span> p1.weight - p2.weight;<br>            &#125;<br>        &#125;; //实现自定义类的比较<br>        PriorityQueue&lt;Pair&gt; pQueue = <span class="hljs-built_in">new</span> PriorityQueue&lt;&gt;(cmp); //创建优先队列<br>        pQueue.offer(<span class="hljs-built_in">new</span> Pair(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>));<br>        dist[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span>(!pQueue.isEmpty())&#123;<br>            Pair pair = pQueue.poll();<br>            <span class="hljs-type">int</span> next = pair.dest; <br><br>            <span class="hljs-keyword">if</span>(visited[next])&#123; // 不能省略<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            visited[next] = <span class="hljs-keyword">true</span>;<br>            <span class="hljs-keyword">for</span>(Pair p: adjacentlist.<span class="hljs-keyword">get</span>(next))&#123;<br>                <span class="hljs-type">int</span> v = p.dest, weight = p.weight;<br>                <span class="hljs-keyword">if</span>(!visited[v] &amp;&amp; weight &lt; dist[v])&#123;<br>                    dist[v] = weight;<br>                    pQueue.offer(p);<br>                    parent[v] = next;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; V; i++)&#123;<br>            String str = String.format(&quot;[%s, %s]&quot;, i, parent[i]);<br>            <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(str);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>参考资料：</p><p><ahref="https://www.geeksforgeeks.org/prims-algorithm-using-priority_queue-stl/">Prim’salgorithm using priority_queue in STL</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>图-最小生成树之Kruskal算法</title>
    <link href="/posts/16155/"/>
    <url>/posts/16155/</url>
    
    <content type="html"><![CDATA[<h2 id="最小生成树">最小生成树</h2><blockquote><p>如果<strong>连通图</strong>G的一个子图是一棵包含G的所有顶点的树，则该子图称为G的<strong>生成树</strong>(SpanningTree)。生成树是连通图的包含图中的所有顶点的<strong>极小连通子图</strong>。</p></blockquote><p><strong>最小生成树</strong>（Minimum SpanningTree，简写为MST）是<strong>带权连通图</strong>G所有可能的生成树中权值最小的，其中生成树的权值定义为树中所有边的权值之和。</p><p>假设无向连通图G=(V，E)，V为节点集，E为边集。G的最小生成树具有如下性质：1. MST有|V|个节点，|V|-1条边。 2.MST是<strong>连通</strong>的，即只有一个连通分量。 3. MST是没有环路的。4. <em>一个图可能有多个MST。</em></p><p>示例如下图所示。 <img src="/images/graph/MST.png"alt="最小生成树" /></p><p>注意：只有连通图才有生成树，非连通图只有生成森林。</p><h2 id="kruskal算法">Kruskal算法</h2><p>Kruskal算法是一种用于解决最小生成树问题的<strong>贪心算法</strong>，每一轮选择权值最小且不会构成回路的边加入到结果中，也称为<strong>加边法</strong>。</p><p>基本思路为： （1）将集合中的所有边按照权值从小到大的顺序进行排序。（2）选择权值最小的边，判断这条边的两个节点是否属于同一个连通分量。如果两个节点属于同一个连通分量，则添加这条边会产生回路，因此需要丢弃这条边；反之，则将这条边添加到最小生成树集合中。重复这一步骤，直到最小生成树集合中的边数为M-1或者所有边均判断完毕，其中M为节点数目。</p><p>在具体实现中，需要定义一个类来表示边结构，并且需要重写比较方法实现该类对象的升序排序。同时，为了判断两个节点是否属于同一个集合，还需要使用<strong>并查集</strong>这种数据结构。</p><p>代码如下： <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">class</span> KruskalMST&#123;<br>    static <span class="hljs-keyword">class</span> Edge&#123;<br>        <span class="hljs-type">int</span> x;<br>        <span class="hljs-type">int</span> y;<br>        <span class="hljs-type">int</span> weight;<br><br>        <span class="hljs-built_in">public</span> Edge(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> weight)&#123;<br>            this.x = x;<br>            this.y = y;<br>            this.weight = weight;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">int</span> V; // 节点数<br>    <span class="hljs-type">int</span>[] parent; // 保存父节点下标<br>    <span class="hljs-type">int</span>[] rank; // 保存树的高度<br>    List&lt;Edge&gt; edges; <br><br>    <span class="hljs-built_in">public</span> KruskalMST(<span class="hljs-type">int</span> V)&#123;<br>        this.V = V;<br>        edges = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>        parent = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[V];<br>        rank = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[V];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; V; i++)&#123;<br>            parent[i] = i;<br>            rank[i] = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> addEdge(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> weight)&#123;<br>        edges.<span class="hljs-keyword">add</span>(<span class="hljs-built_in">new</span> Edge(x, y, weight));<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> <span class="hljs-type">int</span> find(<span class="hljs-type">int</span> i)&#123;<br>        <span class="hljs-keyword">if</span>(parent[i] != i)&#123;<br>            parent[i] = find(parent[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> parent[i];<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> <span class="hljs-keyword">union</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)&#123;<br>        <span class="hljs-type">int</span> rootX = find(x);<br>        <span class="hljs-type">int</span> rootY = find(y);<br><br>        <span class="hljs-keyword">if</span>(rootX == rootY)&#123;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(rank[rootX] &lt; rank[rootY])&#123;<br>            parent[rootX] = rootY;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(rank[rootX] &gt; rank[rootY])&#123;<br>            parent[rootY] = rootX;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            parent[rootX] = rootY;<br>            rank[rootY]++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> kruskal()&#123;<br>        edges.sort(<span class="hljs-built_in">new</span> Comparator&lt;Edge&gt;() &#123; <br>            <span class="hljs-built_in">public</span> <span class="hljs-type">int</span> compare(Edge e1, Edge e2)&#123;<br>                <span class="hljs-keyword">return</span> e1.weight - e2.weight;<br>            &#125;<br>        &#125;);<br><br>        List&lt;Edge&gt; mst = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;(); // 保存最小生成树<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(mst.size() &lt; V - <span class="hljs-number">1</span> &amp;&amp; i &lt; edges.size())&#123;<br>            Edge edge = edges.<span class="hljs-keyword">get</span>(i);<br>            <span class="hljs-type">int</span> rootX = find(edge.x);<br>            <span class="hljs-type">int</span> rootY = find(edge.y);<br><br>            <span class="hljs-keyword">if</span>(rootX != rootY)&#123;  // 根节点不同，说明不在同一个连通分量中<br>                <span class="hljs-keyword">union</span>(rootX, rootY);<br>                mst.<span class="hljs-keyword">add</span>(edge);<br>            &#125;<br><br>            i++;<br>        &#125;<br><br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;最小生成树为：&quot;);<br>        <span class="hljs-type">int</span> <span class="hljs-keyword">cost</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(Edge e: mst)&#123;<br>            <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(String.format(&quot;[%s, %s, %s]&quot;, e.x, e.y, e.weight));<br>            <span class="hljs-keyword">cost</span> += e.weight;<br>        &#125;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;总成本为：&quot; + <span class="hljs-keyword">cost</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>Kruskal算法的时间复杂度主要取决于边的排序算法，时间复杂度最好能够到达O(ElogE)，其中E为边数。由此也可以看出，当图中边的数目较少（即稀疏图）时，使用Kruskal算法的效果较好。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>并查集</title>
    <link href="/posts/61809/"/>
    <url>/posts/61809/</url>
    
    <content type="html"><![CDATA[<h2 id="基本思想">基本思想</h2><p><strong>并查集</strong>（Union-Find）是一种树型的数据结构，通常使用<strong>森林</strong>来表示，每一棵树表示一个集合，树中的节点表示集合中的元素，树的根节点作为一个集合的标识。示例如图所示。<img src="/images/UnionFind/UnionFind.png" alt="并查集" /></p><p>并查集有<strong>合并</strong>（Union）和<strong>查找</strong>（Find）两种基本操作：（1）查找：查找某一个节点所属的集合，即查找某一个节点所在树的根节点。（2）合并：将两个节点所属的两个不相交集合（DisjointSet）合并为一个集合，即将两棵树合并为一棵树。</p><p>在具体实现中，使用<code>parent</code>数组保存父节点下标。初始化时，每一个节点可以视作一个集合，因此让每一个节点的父指针指向自身。查找时，如果一个节点的父节点等于自身，则该节点为根节点；反之，则需要递归（或迭代）查找父节点。合并时，需要先查找两个节点的所在树的根节点，判断它们是否相同。如果相同，则说明两个节点在同一个集合，无需合并；反之，则需要让一个根节点指向另一个根节点。</p><p>代码如下： <figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">class</span> UnionFindSet &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] parent; <span class="hljs-comment">//保存父节点下标</span><br><br>    <span class="hljs-keyword">public</span> UnionFindSet(<span class="hljs-keyword">int</span> <span class="hljs-keyword">size</span>)&#123;<br>        parent = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-keyword">size</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">size</span>; i++)&#123;<br>            parent[i] = i;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//查找根节点</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-keyword">find</span>(<span class="hljs-keyword">int</span> i)&#123;<br>        <span class="hljs-keyword">if</span>(parent[i] == i) &#123;<br>            <span class="hljs-keyword">return</span> parent[i];<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">find</span>(parent[i]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//合并两个节点所属的集合</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> union(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)&#123;<br>        <span class="hljs-keyword">int</span> rootX = <span class="hljs-keyword">find</span>(x);<br>        <span class="hljs-keyword">int</span> rootY = <span class="hljs-keyword">find</span>(y);<br><br>        <span class="hljs-keyword">if</span>(rootX == rootY)&#123;  <br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        parent[rootX] = rootY;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>注意：<strong>合并是对根节点进行的操作</strong></p><h2 id="并查集的优化">并查集的优化</h2><p>查找操作会一直向上查找根节点，其执行效率与<strong>树的高度</strong>相关。树的高度越大，查找效率就越低。假设树中有n个节点，查找操作的最坏时间复杂度为O(n)，此时树的高度为n。为了尽可能减少树的高度，通常结合使用以下两种方法进行优化。</p><p><strong>1.按秩合并（Union by Rank）</strong></p><p>合并时，将高度较小的树合并到较大的树上，合并后的树的高度等于较大的树的高度。如果将较大的树合并到较小的树上，则合并后树的高度会增加。在具体实现中，需要使用一个<code>rank</code>数组来保存所在树的高度，只有在根节点处该数组才有意义。</p><p><strong>2.路径压缩（Path Compression）</strong></p><p>查找时，让每一个节点的父指针直接指向树的根节点，降低树的高度。在代码中递归调用查找函数，在<strong>回溯</strong>过程中，可以让整条路径上的节点的父指针都指向根节点。（非常巧妙！）</p><p>示例如图所示。 <img src="/images/UnionFind/UnionFind_Improvement.png"alt="并查集的优化" /></p><p>代码： <figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">//优化之后的并查集</span><br><span class="hljs-keyword">class</span> UnionFindSet &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] parent;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] rank; <span class="hljs-comment">// 保存树的高度</span><br><br>    <span class="hljs-keyword">public</span> UnionFindSet(<span class="hljs-keyword">int</span> <span class="hljs-keyword">size</span>)&#123;<br>        parent = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-keyword">size</span>];<br>        rank = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-keyword">size</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">size</span>; i++)&#123;<br>            parent[i] = i;<br>            rank[i] = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//路径压缩</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-keyword">find</span>(<span class="hljs-keyword">int</span> i)&#123;<br>        <span class="hljs-keyword">if</span>(parent[i] != i)&#123;<br>            parent[i] = <span class="hljs-keyword">find</span>(parent[i]); <span class="hljs-comment">//巧妙使用递归</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> parent[i];<br>    &#125;<br><br>    <span class="hljs-comment">//按秩合并</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> union(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)&#123;<br>        <span class="hljs-keyword">int</span> rootX = <span class="hljs-keyword">find</span>(x);<br>        <span class="hljs-keyword">int</span> rootY = <span class="hljs-keyword">find</span>(y);<br><br>        <span class="hljs-keyword">if</span>(rootX == rootY)&#123;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(rank[rootX] &lt; rank[rootY])&#123;<br>            parent[rootX] = rootY;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(rank[rootX] &gt; rank[rootY])&#123;<br>            parent[rootY] = rootX;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            parent[rootX] = rootY;<br>            rank[rootY]++;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>参考资料:</p><ol type="1"><li><a href="https://oi-wiki.org/ds/dsu/">并查集</a></li><li><ahref="https://www.geeksforgeeks.org/introduction-to-disjoint-set-data-structure-or-union-find-algorithm/">Introductionto Disjoint Set (Union-Find Algorithm)</a></li><li><ahref="https://cloud.tencent.com/developer/article/2382579">并查集详解（原理+代码实现+应用+优化）</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>图-拓扑排序</title>
    <link href="/posts/29864/"/>
    <url>/posts/29864/</url>
    
    <content type="html"><![CDATA[<p>在有向图中，使用顶点表示活动、有向边表示活动的先后关系，这样的有向图称为顶点活动网（简称<strong>AOV网</strong>）。AOV网是一个<strong>有向无环图</strong>。</p><p>拓扑排序（topologicalsort）是针对有向无环图的排序，即将图中所有节点排成一个线性序列，如果存在从节点u到节点v的有向边，则在线性序列中，节点v只能出现在节点u的后面。注意，<strong>拓扑排序并不一定是唯一的</strong>。</p><p>例如使用AOV网描述课程安排，如下图所示。有的课程需要学完所有的先修课之后才能开始学习，比如离散数学的先修课为高等数学和计算机导论。</p><figure><img src="/images/graph/topological_sort.png" alt="拓扑排序" /><figcaption aria-hidden="true">拓扑排序</figcaption></figure><p>实现拓扑排序的方法主要有以下两种：</p><p><strong>方法一：Kahn算法</strong></p><p>Kahn算法，又称为<strong>入度表算法</strong>，其实现思路为：找出图中<strong>入度为0</strong>的节点并记录下来，将这些节点以及以这些节点为起点的有向边删除，重复这一过程直到所有节点均被删除或者不存在入度为0的节点（即有环）。</p><p>在实际过程中，不需要删除节点及有向边。使用一个入度数组<code>inDegree</code>记录每一个节点的入度，当需要删除某一个节点时，只需要将该节点的所有<em>直接后继</em>节点的入度值减一即可。</p><p>基于邻接表的Kahn算法实现如下： <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Graph</span>&#123;<br>    <span class="hljs-keyword">private</span> List&lt;List&lt;Integer&gt;&gt; adjcentList; <span class="hljs-comment">// 邻接表</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> vertexNum; <span class="hljs-comment">// 节点数目</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Graph</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> vertexNum</span>)</span>&#123;<br>        <span class="hljs-keyword">this</span>.vertexNum = vertexNum;<br>        adjcentList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; vertexNum; i++)&#123;<br>            adjcentList.<span class="hljs-keyword">add</span>(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addEdges</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> i, <span class="hljs-built_in">int</span> j</span>)</span>&#123;<br>        adjcentList.<span class="hljs-keyword">get</span>(i).<span class="hljs-keyword">add</span>(j);<br>    &#125;<br><br>    <span class="hljs-comment">//Kahn算法：BFS</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">topologicalSort</span>()</span>&#123;<br>        <span class="hljs-built_in">int</span>[] inDegree = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[vertexNum]; <span class="hljs-comment">// 入度数组</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; vertexNum; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j: adjcentList.<span class="hljs-keyword">get</span>(i))&#123;<br>                inDegree[j]++;<br>            &#125;<br>        &#125;<br><br>        Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        ArrayList&lt;Integer&gt; topoList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(); <span class="hljs-comment">// 保存拓扑序列</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; vertexNum; i++)&#123;<br>            <span class="hljs-keyword">if</span>(inDegree[i] == <span class="hljs-number">0</span>)&#123;<br>                queue.offer(i);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>            <span class="hljs-built_in">int</span> v = queue.poll();<br>            topoList.<span class="hljs-keyword">add</span>(v);<br><br>            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j: adjcentList.<span class="hljs-keyword">get</span>(v))&#123; <br>                inDegree[j]--;<br>                <span class="hljs-keyword">if</span>(inDegree[j] == <span class="hljs-number">0</span>)&#123; <span class="hljs-comment">//只查找直接后继即可</span><br>                    queue.offer(j);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(topoList.size() &lt; vertexNum)&#123;<br>            System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;图中有环&quot;</span>);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <br>        System.<span class="hljs-keyword">out</span>.println(topoList.toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>注意：当从队列中弹出一个节点后，将其所有直接后继的入度值减一，然后<em>直接判断这些直接后继的入度值是否为0</em>。<em>除了这些直接后继以外，是否还存在其他入度为0的节点需要入队？</em></p><p>设当前出队的节点为u，假设存在一个入度为0的节点v不是u的直接后继，那么节点v存在以下两种情况：（1）第一种情况：节点v本来就没有任何前驱节点，那么它在队列初始化时就已经入队。（2）第二种情况：节点v存在直接前驱，而当前v的入度为0，说明它的直接前驱已经被访问过并且出队了，那么节点v肯定已经被加入到队列中。综上，入度为0并且不是u的直接后继的节点一定已经入队过了。</p><p><strong>方法二：深度优先搜索</strong></p><p>深度优先搜索的算法思路与Kahn算法正好相反。Kahn算法是找出入度为0的节点；而DFS的本质则是找出<strong>出度为0</strong>的节点，删除这些节点以及以这些节点为终点的有向边，从而获得一个<strong>逆拓扑序列</strong>，并且通过<strong>栈</strong>的先进后出的特性实现拓扑排序。</p><p>在实际过程中，不需要删除节点和有向边，使用一个<code>visit</code>数组来判断节点是否被访问过。</p><p>从某一个节点u出发进行深度优先搜索，会一直向下搜索，直到所有路径均搜索完毕才会回溯到节点u，而<strong>回溯的过程就是进行逆拓扑排序的过程</strong>。因此，当节点u没有后继节点或者其所有后继节点均已被访问，将节点u压入栈中，此时从栈顶到栈底即为以节点u为起点的拓扑序列。</p><p>同时，如果只用未访问和已访问两个状态，则无法判断图中是否有环。为了解决这一问题，需要添加一个状态——<em>正在访问</em>，在<code>visit</code>数组中，0表示未访问，1表示正在访问，2表示已访问。对某一个节点进行DFS时，会将该节点的状态置为1；如果这个节点的所有后继均访问完毕，则将该节点的状态置为2。如果在访问后继节点的过程中，出现状态为1的节点，则说明图中有环，无法进行拓扑排序。</p><p>基于邻接表的DFS实现如下： <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-type">void</span> topologicalSort()&#123;<br>    //表示节点状态:<span class="hljs-number">0</span>表示未访问，<span class="hljs-number">1</span>表示正在访问，<span class="hljs-number">2</span>表示已完成访问<br>    <span class="hljs-type">int</span>[] visited = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[vertexNum]; <br>    Stack&lt;<span class="hljs-type">Integer</span>&gt; stack = <span class="hljs-built_in">new</span> Stack&lt;&gt;();<br>    <span class="hljs-type">boolean</span>[] <span class="hljs-keyword">valid</span> = <span class="hljs-built_in">new</span> <span class="hljs-type">boolean</span>[<span class="hljs-number">1</span>]; //判断是否有环<br>    <span class="hljs-keyword">valid</span>[<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; vertexNum; i++)&#123;<br>        <span class="hljs-keyword">if</span>(visited[i] == <span class="hljs-number">0</span>)&#123;<br>            dfs(visited, stack, <span class="hljs-keyword">valid</span>, i);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(!<span class="hljs-keyword">valid</span>[<span class="hljs-number">0</span>])&#123;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;图中有环&quot;);<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span>(!stack.isEmpty())&#123;<br>        <span class="hljs-type">int</span> v = stack.pop();<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.print(v + &quot; &quot;);<br>    &#125;<br>&#125;<br><br><span class="hljs-built_in">public</span> <span class="hljs-type">void</span> dfs(<span class="hljs-type">int</span>[] visited, Stack&lt;<span class="hljs-type">Integer</span>&gt; stack, <span class="hljs-type">boolean</span>[] <span class="hljs-keyword">valid</span>, <span class="hljs-type">int</span> v)&#123;<br>    visited[v] = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j:adjcentList.<span class="hljs-keyword">get</span>(v))&#123;<br>        <span class="hljs-keyword">if</span>(visited[j] == <span class="hljs-number">0</span>)&#123;<br>            dfs(visited, stack, <span class="hljs-keyword">valid</span>, j);<br><br>            <span class="hljs-keyword">if</span>(!<span class="hljs-keyword">valid</span>[<span class="hljs-number">0</span>])&#123;<br>                <span class="hljs-keyword">return</span> ;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(visited[j] == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">valid</span>[<span class="hljs-number">0</span>] = <span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>    &#125;<br><br>    stack.push(v);<br>    visited[v] = <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>参考资料：</p><ol type="1"><li><ahref="https://www.geeksforgeeks.org/topological-sorting/">TopologicalSorting</a></li><li><ahref="https://leetcode.cn/problems/course-schedule/solutions/359392/ke-cheng-biao-by-leetcode-solution/">课程表</a></li><li><ahref="https://blog.csdn.net/m0_63997099/article/details/136818071?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22136818071%22%2C%22source%22%3A%22m0_63997099%22%7D">数据结构：图的拓扑排序与关键路径</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>图的遍历</title>
    <link href="/posts/42854/"/>
    <url>/posts/42854/</url>
    
    <content type="html"><![CDATA[<h2 id="广度优先搜索bfs">广度优先搜索BFS</h2><p>广度优先搜索的基本思想是从初始节点出发，访问它的所有相邻节点，然后对每一个相邻节点执行相同的操作，直到所有节点遍历完毕。</p><p>广度优先搜索使用<strong>队列</strong>保存待处理的节点，遵守先进先出（FIFO）的原则。首先将初始节点入队，然后从队列中取出节点，并且将该节点的所有未被访问过的相邻节点入队，重复这一过程直到所有节点都被访问。其中需要使用一个数组<code>visited</code>标记节点是否被访问过。</p><p>基于邻接矩阵的BFS实现： <figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">boolean</span>[] visited; <span class="hljs-comment">//标记节点是否被访问过</span><br><br><span class="hljs-comment">//从节点v开始广度优先遍历图g</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] g, <span class="hljs-type">int</span> v)</span></span>&#123;<br>    <span class="hljs-type">int</span> vertexNum = g.length;<br>    Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    queue.<span class="hljs-built_in">offer</span>(v);<br>    visited[v] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">while</span>(!queue.<span class="hljs-built_in">isEmpty</span>())&#123;<br>        <span class="hljs-type">int</span> i = queue.<span class="hljs-built_in">poll</span>();<br>        System.out.<span class="hljs-built_in">print</span>(i+<span class="hljs-string">&quot; &quot;</span>);<br><br>        <span class="hljs-comment">//将所有未被访问过的相邻节点入队</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; vertexNum; j++)&#123;<br>            <span class="hljs-keyword">if</span>(!visited[j] &amp;&amp; g[i][j]==<span class="hljs-number">1</span>)&#123;<br>                queue.<span class="hljs-built_in">offer</span>(j);<br>                visited[j] = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>注意： 1.必须在节点入队时修改标记，而不是节点出队时修改，否则可能会导致某些节点重复入队。2.上述代码中的方法<code>bfs</code>能够实现广度优先搜索。但是对于<strong>非连通</strong>的无向图来说，一次BFS只能遍历一个<strong>连通分量</strong>，不能完全遍历整张图。因此需要对每一个连通分量分别进行一次BFS，代码如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">bfsTraverse</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] g)</span></span>&#123;<br>    <span class="hljs-type">int</span> vertexNum = g.length; <span class="hljs-comment">//顶点数</span><br>    visited = <span class="hljs-keyword">new</span> <span class="hljs-type">boolean</span>[vertexNum];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; vertexNum; i++)&#123;<br>        <span class="hljs-keyword">if</span>(!visited[i])&#123;<br>            <span class="hljs-built_in">bfs</span>(g, i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="深度优先搜索dfs">深度优先搜索DFS</h2><p>图的深度优先搜索与树的<strong>先序遍历</strong>类似，其基本思想是从起始节点出发，沿着某一条路径遍历，直到无法继续进行，则<strong>回溯</strong>并沿着其他分支继续遍历，直到图中所有节点遍历完毕。</p><p>深度优先搜索使用<strong>栈</strong>保存待处理的节点，遵守先进后出的原则。首先将起始节点入栈，然后从栈中弹出栈顶节点，将栈顶节点的所有未被访问过的相邻节点入栈，重复这一过程直到所有节点都被访问。</p><p>基于邻接矩阵的DFS实现： <figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">boolean</span>[] visited; <span class="hljs-comment">//标记节点是否被访问过</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">dfsTraverse</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] g)</span></span>&#123;<br>    <span class="hljs-type">int</span> vertexNum = g.length;<br>    visited = <span class="hljs-keyword">new</span> <span class="hljs-type">boolean</span>[vertexNum];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; vertexNum; i++)&#123;<br>        <span class="hljs-keyword">if</span>(!visited[i])&#123;<br>            <span class="hljs-built_in">dfs</span>(g, i);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//非递归形式dfs：从节点v开始深度优先遍历图g</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] g, <span class="hljs-type">int</span> v)</span></span>&#123;<br>    <span class="hljs-type">int</span> vertexNum = g.length;<br>    Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>    visited[v] = <span class="hljs-literal">true</span>;<br>    stack.<span class="hljs-built_in">push</span>(v);<br>    <span class="hljs-keyword">while</span>(!stack.<span class="hljs-built_in">isEmpty</span>())&#123;<br>        <span class="hljs-type">int</span> i = stack.<span class="hljs-built_in">pop</span>();<br>        System.out.<span class="hljs-built_in">print</span>(i+<span class="hljs-string">&quot; &quot;</span>);<br><br>        <span class="hljs-comment">//将所有未被访问过的相邻节点入栈</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; vertexNum; j++)&#123;<br>            <span class="hljs-keyword">if</span>(!visited[j] &amp;&amp; g[i][j] == <span class="hljs-number">1</span>)&#123;<br>                stack.<span class="hljs-built_in">push</span>(j);<br>                visited[j] = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>递归形式的dfs实现代码如下： <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//递归形式dfs：从节点v开始深度优先遍历图g</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[][] g, <span class="hljs-built_in">int</span> v</span>)</span>&#123;<br>    <span class="hljs-built_in">int</span> vertexNum = g.length;<br>    System.<span class="hljs-keyword">out</span>.print(v + <span class="hljs-string">&quot; &quot;</span>); <span class="hljs-comment">//需要注意这行代码的位置</span><br>    visited[v] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; vertexNum; i++)&#123;<br>        <span class="hljs-keyword">if</span>(!visited[i] &amp;&amp; g[v][i] == <span class="hljs-number">1</span>)&#123;<br>            dfs(g, i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>与广度优先搜索中介绍的情况一致，针对非连通的无向图这种情况，同样需要对每一个连通分量分别进行一次DFS，上述代码中的<code>dfsTraverse</code>方法解决了这一问题。</p><p>参考资料：</p><ol type="1"><li><ahref="https://blog.csdn.net/qq_40310148/article/details/106749972">数据结构笔记——图的广度优先遍历（BFS）</a></li><li><ahref="https://blog.csdn.net/m0_63997099/article/details/136623378">数据结构：图的存储与遍历</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>图的存储结构</title>
    <link href="/posts/12592/"/>
    <url>/posts/12592/</url>
    
    <content type="html"><![CDATA[<h3 id="邻接矩阵">1.邻接矩阵</h3><p>邻接矩阵（adjacencymatrix）是一个<strong>二维数组</strong>，用来表示图中节点的关系。对于非带权图，如果节点i和节点j之间存在边，则二维数组中i行j列元素为1，否则为0；对于带权图（也称为<strong>网</strong>），如果节点i和节点j之间存在边，则二维数组中i行j列元素为边的权重，否则为无穷大。</p><p>性质： 1.无向图的邻接矩阵一定为<strong>对称</strong>矩阵，有向图的邻接矩阵则不一定。2.无向图的邻接矩阵i行非零元素个数为节点i的<strong>度</strong>。而在有向图中，i行非零元素个数为节点i的<strong>出度</strong>，i列非零元素个数为节点i的<strong>入度</strong>。3. 无向图和有向图的邻接矩阵的<strong>对角线元素均为0</strong>。</p><p>示例如图所示。</p><figure><img src="/images/graph/adjacecy_matrix.png" alt="邻接矩阵" /><figcaption aria-hidden="true">邻接矩阵</figcaption></figure><p>实现代码: <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Graph</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> vertexNum; <span class="hljs-comment">//节点数目</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> edgeNum; <span class="hljs-comment">//边数目</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span>[][] edges; <span class="hljs-comment">//邻接矩阵</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Graph</span>()</span>&#123;<br>        vertexNum = <span class="hljs-number">0</span>;<br>        edgeNum = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Graph</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> vertexNum</span>)</span>&#123;<br>        <span class="hljs-keyword">this</span>.vertexNum = vertexNum;<br>        <span class="hljs-keyword">this</span>.edges = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[vertexNum][vertexNum];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addEdges</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> i, <span class="hljs-built_in">int</span> j</span>)</span>&#123;<br>        edges[i][j] = <span class="hljs-number">1</span>;<br>        edges[j][i] = <span class="hljs-number">1</span>; <span class="hljs-comment">//如果为有向图，则这一行可以去掉</span><br>        edgeNum++;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">getVertexNum</span>()</span>&#123;<br>        <span class="hljs-keyword">return</span> vertexNum;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">getEdge</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> i, <span class="hljs-built_in">int</span> j</span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> edges[i][j];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">getEdgeNum</span>()</span>&#123;<br>        <span class="hljs-keyword">return</span> edgeNum;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printGraph</span>()</span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; vertexNum; i++)&#123;<br>            System.<span class="hljs-keyword">out</span>.println(Arrays.toString(edges[i]));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>对于稀疏图，邻接矩阵会造成大量的空间浪费，因此邻接矩阵更加适合稠密图。同时邻接矩阵也适用于一些需要矩阵运算的场景。</p><h3 id="邻接表">2.邻接表</h3><p>邻接表（adjacencylist）是一种顺序存储和链式存储相结合的存储结构，由节点表和边表两部分组成。节点表的作用是记录图中的所有节点，并且每一个节点指向一个边表。边表包含与当前节点连接的所有邻接节点。</p><p>对于无向图，节点i的边表表示节点i的所有邻接节点的集合；对于有向图，节点i的边表则表示以节点i为起点（即弧头）的所有有向边的弧尾节点的集合。</p><p>示例如下图所示。</p><figure><img src="/images/graph/adjacency_list.png" alt="邻接表" /><figcaption aria-hidden="true">邻接表</figcaption></figure><p>实现代码： <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">GraphAdjList</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> vertexNum;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> edgeNum;<br>    <span class="hljs-keyword">private</span> List&lt;List&lt;Integer&gt;&gt; adjacencyList; <span class="hljs-comment">//邻接表</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GraphAdjList</span>()</span>&#123;<br>        vertexNum = <span class="hljs-number">0</span>;<br>        edgeNum = <span class="hljs-number">0</span>;<br>    &#125; <br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GraphAdjList</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> vertexNum</span>)</span>&#123;<br>        <span class="hljs-keyword">this</span>.vertexNum = vertexNum;<br>        <span class="hljs-keyword">this</span>.adjacencyList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(vertexNum);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; vertexNum; i++)&#123;<br>            adjacencyList.<span class="hljs-keyword">add</span>(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;());<br>        &#125; <br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addEdges</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> i, <span class="hljs-built_in">int</span> j</span>)</span>&#123;<br>        adjacencyList.<span class="hljs-keyword">get</span>(i).<span class="hljs-keyword">add</span>(j);<br>        adjacencyList.<span class="hljs-keyword">get</span>(j).<span class="hljs-keyword">add</span>(i); <span class="hljs-comment">//如果为有向图，则这一行可以去掉</span><br>        edgeNum++;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">getVertexNum</span>()</span>&#123;<br>        <span class="hljs-keyword">return</span> vertexNum;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">getEdgeNum</span>()</span>&#123;<br>        <span class="hljs-keyword">return</span> edgeNum;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> boolean <span class="hljs-title">getEdge</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> i, <span class="hljs-built_in">int</span> j</span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> adjacencyList.<span class="hljs-keyword">get</span>(i).contains(j);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printGraph</span>()</span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; vertexNum; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j: adjacencyList.<span class="hljs-keyword">get</span>(i))&#123;<br>                System.<span class="hljs-keyword">out</span>.println(String.format(<span class="hljs-string">&quot;[%s, %s]&quot;</span>, i, j));<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>对于稀疏图，邻接表比邻接矩阵更节省空间。但是对于有向图，邻接表找某一个节点的入度的效率较低，因此通常还会构建一个<strong>逆邻接表</strong>，以方便查找入度。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>串匹配-字典树</title>
    <link href="/posts/43931/"/>
    <url>/posts/43931/</url>
    
    <content type="html"><![CDATA[<p>字典树(<strong>Trie</strong>)，也称为<strong>前缀树</strong>或单词查找树，是一种树型的数据结构，常用于存储字符串集合。许多编辑器或搜索引擎的词频统计、前缀匹配、自动补全、拼写检查等功能都是基于字典树实现的。其性质如下：</p><p>1.<em>根节点不包含字符</em>，除根节点外每一个节点都只包含一个字符。2.<em>从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串</em>。3.每个节点的所有子节点包含的字符都不相同。</p><p>示例如下图所示。 <img src="/images/patternmatch/Trie.png"alt="字典树" /></p><p>与字典树相关的操作主要有以下三个：1.插入：将一个字符串逐个字符插入到字典树中。2.查找：判断某一个字符串是否在字典树中。3.前缀搜索：判断某一前缀是否在字典树中。与查找类似，但不需要判断最后一个字符是否为整个字符串的结尾。</p><p>这里假设每个字符串只包含26个小写英文字母，代码如下：<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TrieNode</span>&#123;<br>    TrieNode[] children;<br>    <span class="hljs-type">boolean</span> isEnd;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TrieNode</span><span class="hljs-params">()</span></span>&#123;<br>        children = <span class="hljs-keyword">new</span> TrieNode[<span class="hljs-number">26</span>]; <span class="hljs-comment">// 假设字符串只包含小写英文字母</span><br>        isEnd = <span class="hljs-literal">false</span>; <span class="hljs-comment">//是否为一个字符串的结尾</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span> &#123;<br>    <span class="hljs-keyword">private</span> TrieNode root;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Trie</span><span class="hljs-params">()</span> </span>&#123;<br>        root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TrieNode</span>();<br>    &#125;<br>    <br>    <span class="hljs-comment">//插入字符串</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">String</span> <span class="hljs-type">word</span>)</span> </span>&#123;<br>        TrieNode p = root;<br>        <span class="hljs-type">char</span>[] ch = <span class="hljs-type">word</span>.<span class="hljs-built_in">toCharArray</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ch.length; i++)&#123;<br>            <span class="hljs-type">int</span> j = ch[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span>(p.children[j] == null)&#123;<br>                p.children[j] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TrieNode</span>();<br>            &#125;<br>            p = p.children[j];<br>        &#125;<br>        p.isEnd = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">//判断字符串是否已经插入</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-type">String</span> <span class="hljs-type">word</span>)</span> </span>&#123;<br>        TrieNode p = root;<br>        <span class="hljs-type">char</span>[] ch = <span class="hljs-type">word</span>.<span class="hljs-built_in">toCharArray</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ch.length; i++)&#123;<br>            <span class="hljs-type">int</span> j = ch[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span>(p.children[j] == null)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            p = p.children[j];<br>        &#125;<br>        <span class="hljs-keyword">return</span> p.isEnd;<br>    &#125;<br>    <br>    <span class="hljs-comment">//判断前缀是否存在</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title">startsWith</span><span class="hljs-params">(<span class="hljs-type">String</span> prefix)</span> </span>&#123;<br>        TrieNode p = root;<br>        <span class="hljs-type">char</span>[] ch = prefix.<span class="hljs-built_in">toCharArray</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ch.length; i++)&#123;<br>            <span class="hljs-type">int</span> j = ch[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span>(p.children[j] == null)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            p = p.children[j];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>参考资料: <ahref="https://blog.csdn.net/m0_46202073/article/details/107253959">【图解算法】模板+变式——带你彻底搞懂字典树(Trie树)</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>串匹配-BM算法</title>
    <link href="/posts/22932/"/>
    <url>/posts/22932/</url>
    
    <content type="html"><![CDATA[<p><strong>Boyer-Moore算法</strong>，即BM算法，是一种非常高效的字符串搜索算法，擅长处理大规模文本和长模式串。它的核心思想是当主串与模式串在某一位置失配时，根据某种规则，跳过一些不必要的比较，提高字符串匹配的效率。目前大多数文本编辑器中的字符串查找、替换功能都是使用BM算法实现的。</p><p>BM算法由坏字符和好后缀两个启发式规则组成，下面将对这两部分进行具体介绍。</p><h2 id="坏字符规则">坏字符规则</h2><p>与KMP算法不同，BM算法是从模式串的末尾开始，<strong>自右向左</strong>与主串进行匹配的。当第一次出现主串的字符与模式串的字符不匹配时，主串的相应字符称为<strong>坏字符</strong>。</p><p>1.如果模式串中不存在该坏字符，则说明模式串中任何一个字符都不能与坏字符匹配，因此将模式串向右移动，使模式串的第一个字符与主串坏字符的后一个字符对齐，并继续进行匹配。如下图所示。</p><figure><img src="/images/patternmatch/BM-nobadchar.png"alt="模式串中不存在坏字符" /><figcaption aria-hidden="true">模式串中不存在坏字符</figcaption></figure><p>2.如果模式串中存在该坏字符，则将模式串向右移动，使模式串的坏字符与主串的坏字符对齐，并继续进行匹配。其中需要注意，如果模式串含有多个坏字符，则必须选择<strong>最右侧</strong>的坏字符与主串的坏字符对齐，否则可能会错过匹配。</p><figure><img src="/images/patternmatch/BM-badchar.png"alt="模式串中存在坏字符" /><figcaption aria-hidden="true">模式串中存在坏字符</figcaption></figure><p>实现思路：采用<strong>哈希</strong>思想，通过数组记录下每一个字符的位置。当一个字符出现多次时，当前位置会覆盖原来记录的位置。假设主串或模式床中的字符均为ASCII字符，一共256个。</p><p>代码： <figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span>[] <span class="hljs-built_in">badCharRule</span>(<span class="hljs-type">String</span> p)&#123;<br>    <span class="hljs-type">int</span> charNum = <span class="hljs-number">256</span>; <span class="hljs-comment">//ASCII字符数目</span><br>    <span class="hljs-type">int</span>[] badChar = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[charNum];<br>    Arrays.<span class="hljs-built_in">fill</span>(badChar, <span class="hljs-number">-1</span>);<br><br>    <span class="hljs-comment">// 记录每一个字符在模式串中出现的最右侧位置</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; p.<span class="hljs-built_in">length</span>(); i++)&#123;<br>        badChar[(<span class="hljs-type">int</span>)p.<span class="hljs-built_in">charAt</span>(i)] = i;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> badChar;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>但是在某些情况下，模式串可能会向左移动，比如主串为"babaaab"，模式串为"aab"。为了避免这种情况，BM算法还使用了好后缀规则。</p><h2 id="好后缀规则">好后缀规则</h2><p>好后缀(goodsuffix)是<strong>主串与模式串匹配的后缀子串</strong>，即坏字符右侧匹配成功的部分。利用好后缀确定模式串的移动次数，可以分为以下三种情况：</p><p>1.除了好后缀本身之外，如果模式串中存在其他与好后缀匹配的子串，则使该子串的第一个字符与主串好后缀的第一个字符对齐，继续进行匹配。注意，如果存在多个子串与好后缀匹配，则需要选择<strong>最右侧</strong>子串，原因与坏字符的相同。如下图所示。</p><figure><img src="/images/patternmatch/BM-goodsuffix.png" alt="存在好后缀" /><figcaption aria-hidden="true">存在好后缀</figcaption></figure><p>2.如果模式串中不存在其他与好后缀匹配的子串，则需要查找好后缀的<strong>真后缀</strong>中是否存在后缀子串与模式串的某一<strong>前缀</strong>匹配，如果匹配，则将该后缀子串在主串中的第一个字符与模式串的第一个字符匹配。<em>真后缀是除了字符串自身以外的所有的后缀子串形成的集合</em>。如下图所示。</p><figure><img src="/images/patternmatch/BM-substring.png"alt="存在好后缀的后缀子串" /><figcaption aria-hidden="true">存在好后缀的后缀子串</figcaption></figure><p>注意：必须是与前缀匹配，否则移动后必然会失配。</p><p>3.如果上述两种情况都没有出现，即模式串中既不存在其他与好后缀匹配的子串，也不存在好后缀的后缀子串与前缀匹配的情况，则需要让模式串向右移动m位，其中m为模式串的长度。</p><p>实现思路：创建两个数组suffix和prefix。suffix[k]表示模式串中与长度为k的后缀相匹配的最右侧子串的起始位置；prefix[k]表示长度为k的后缀是否与前缀匹配，1为匹配，0为不匹配。</p><p>代码: <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public static void good<span class="hljs-constructor">SuffixRule(String <span class="hljs-params">p</span>, <span class="hljs-params">int</span>[] <span class="hljs-params">suffix</span>, <span class="hljs-params">int</span>[] <span class="hljs-params">prefix</span>)</span>&#123;<br>    <span class="hljs-built_in">int</span> m = p.length<span class="hljs-literal">()</span>;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; m - <span class="hljs-number">1</span>; i++)&#123;<br>        <span class="hljs-built_in">int</span> j = i;<br>        <span class="hljs-built_in">int</span> k = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 后缀的长度</span><br><br>        <span class="hljs-keyword">while</span>(j &gt;= <span class="hljs-number">0</span><span class="hljs-operator"> &amp;&amp; </span>p.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">j</span>)</span><span class="hljs-operator"> == </span>p.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">m</span>-<span class="hljs-params">k</span>-1)</span>)&#123;<br>            j--;<br>            k++;<br>            suffix<span class="hljs-literal">[<span class="hljs-identifier">k</span>]</span> = j + <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(j<span class="hljs-operator"> == </span>-<span class="hljs-number">1</span>) prefix<span class="hljs-literal">[<span class="hljs-identifier">k</span>]</span> = <span class="hljs-number">1</span>;  <span class="hljs-comment">//判断是否为前缀</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="基本思想">基本思想</h2><ol type="1"><li>对模式串p进行预处理，得到三个数组badChar、suffix和prefix。</li><li>从模式串p的末尾开始，自右向左与主串进行匹配。当在某一位置失配时，分别按照坏字符规则和好后缀规则计算移动位数，取两者的最大值，并将模式串向右移动。</li><li>重复步骤2，直到匹配成功或者主串匹配完毕。</li></ol><p>注意：<em>在匹配过程中，如果模式串的最后一个字符与主串匹配失败，则不存在好后缀，需要按照坏字符规则计算移动次数。</em></p><p>代码： <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> static <span class="hljs-type">int</span> bm(String t, String p)&#123;<br>    <span class="hljs-type">int</span> n = t.length();<br>    <span class="hljs-type">int</span> m = p.length();<br>    <span class="hljs-type">int</span>[] badChar = badCharRule(p);<br>    <span class="hljs-type">int</span>[] suffix = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[m];<br>    <span class="hljs-type">int</span>[] prefix = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[m];<br>    Arrays.fill(suffix, <span class="hljs-number">-1</span>);<br>    Arrays.fill(prefix, <span class="hljs-number">0</span>);<br>    goodSuffixRule(p, suffix, prefix);<br><br>    <span class="hljs-type">int</span> i = m - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i &lt;= n - <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-type">int</span> j = m - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(j &gt;= <span class="hljs-number">0</span> &amp;&amp; t.charAt(i) == p.charAt(j))&#123;<br>            i<span class="hljs-comment">--;</span><br>            j<span class="hljs-comment">--;</span><br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(j == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br><br>        //计算坏字符规则的移动位数<br>        <span class="hljs-type">int</span> badCharMove = m - <span class="hljs-number">1</span> - badChar[(<span class="hljs-type">int</span>)t.charAt(i)];<br><br>        //计算好后缀规则的移动位数<br>        <span class="hljs-type">int</span> goodSuffixMove = <span class="hljs-number">0</span>;<br>        //当j==m<span class="hljs-number">-1</span>，即不存在好后缀时，按照坏字符规则进行移动<br>        <span class="hljs-keyword">if</span>(j &lt; m - <span class="hljs-number">1</span>)&#123;<br>            goodSuffixMove = moveGoodSuffix(j, m, suffix, prefix);<br>        &#125;<br><br>        i += Math.max(badCharMove, goodSuffixMove);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br>//计算好后缀规则的移动位数<br><span class="hljs-built_in">public</span> static <span class="hljs-type">int</span> moveGoodSuffix(<span class="hljs-type">int</span> j, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span>[] suffix, <span class="hljs-type">int</span>[] prefix)&#123;<br>    <span class="hljs-type">int</span> k = m - <span class="hljs-number">1</span> - j;<br>    <span class="hljs-keyword">if</span>(suffix[k] != <span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-keyword">return</span> m - <span class="hljs-number">1</span> - suffix[k];<br>    &#125;<br><br>    //找出最长真后缀，同时也是前缀<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = k - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i<span class="hljs-comment">--)&#123;</span><br>        <span class="hljs-keyword">if</span>(prefix[i] == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> m - <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> m;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>参考资料:</p><ol type="1"><li><ahref="https://blog.csdn.net/weixin_43004044/article/details/134730908">【算法】Boyer-Moore算法</a></li><li><a href="https://segmentfault.com/a/1190000022490177">字符串匹配之BM 算法</a></li><li><ahref="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/539634/zhe-ke-neng-shi-quan-wang-zui-xi-de-kmp-8zl57/">【动画模拟】这可能是全网最细的KMP 讲解！（BF,BM,KMP）</a></li></ol><p>在第二篇文章中，计算好后缀规则的移动位数的代码有错误，会出现死循环。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>串匹配-KMP算法</title>
    <link href="/posts/35766/"/>
    <url>/posts/35766/</url>
    
    <content type="html"><![CDATA[<h2 id="串匹配">串匹配</h2><p>串匹配，也称为<strong>模式匹配</strong>，即对于一个字符串P，在某一个字符串T中找出与串P相同的子串，并返回该子串在T中的位置。其中字符串P称为<strong>模式串</strong>，待查找的字符串T称为<strong>目标串</strong>或者<strong>主串</strong>。</p><h2 id="bf算法">BF算法</h2><p>BF(Brute Force)算法，又称为朴素模式匹配算法。</p><p>算法思路：从主串的第一个字符开始，与模式串的第一个字符进行比较，如果相同，则依次比较后续字符；如果不相同，即主串和模式串<strong>失配</strong>，则从主串的后一个字符开始，重新与模式串的第一个字符进行比较。直到模式串与主串中某一个连续序列相同，则匹配成功；反之，则匹配失败。</p><p>代码： <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public static <span class="hljs-built_in">int</span> brute<span class="hljs-constructor">Force(String <span class="hljs-params">t</span>, String <span class="hljs-params">p</span>)</span>&#123;<br>    <span class="hljs-built_in">int</span> n = t.length<span class="hljs-literal">()</span>; <span class="hljs-comment">//主串长度</span><br>    <span class="hljs-built_in">int</span> m = p.length<span class="hljs-literal">()</span>; <span class="hljs-comment">//模式串长度</span><br>    <span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i &lt;= n - m)&#123;<br>        <span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(j &lt; m<span class="hljs-operator"> &amp;&amp; </span>t.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span>+<span class="hljs-params">j</span>)</span><span class="hljs-operator"> == </span>p.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">j</span>)</span>)&#123;<br>            j++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(j<span class="hljs-operator"> == </span>m)&#123; <span class="hljs-comment">// 匹配成功</span><br>            return i;<br>        &#125;<br>        i++;<br>    &#125;<br>    return -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>时间复杂度O(nm)，其中n为主串的长度，m为模式串的长度。</p><p>注意：<strong>匹配失败不等于失配</strong>。</p><h2 id="kmp算法">KMP算法</h2><p>KMP算法是对朴素模式匹配算法的改进。在朴素模式匹配算法中，当主串和模式串失配时，主串的指针将会<strong>回溯</strong>，从而影响到算法的匹配效率。而KMP算法<strong><em>利用已经部分匹配过的信息避免回溯</em></strong>，主串的指针从不回溯，一直向右移动。</p><h3 id="真前缀和真后缀">真前缀和真后缀</h3><p>为了便于理解KMP算法的思想，需要引入两个基本概念。</p><p><strong>真前缀（properprefix）</strong>：由不包括字符串最后一个字符的前缀子串形成的集合。<strong>真后缀（propersuffix）</strong>：由不包括字符串第一个字符的后缀子串形成的集合。</p><p>例如，对于字符串s="abc"，其真前缀为{"a","ab"}，真后缀为{"c","bc"}；对于字符串S="aaa"来说，其真前缀为{"a","aa"}，真后缀为{"a","aa"}。</p><h3 id="部分匹配表">部分匹配表</h3><p>部分匹配表（Partial MatchTable，PMT）记录的是从模式串的第一个字符到当前位置形成的字符串中既是真前缀，同时也是真后缀的最长子串的长度，即<strong>最长相等真前缀真后缀的长度</strong>。在本文中用<em>next数组</em>表示PMT表。</p><p>例如，对于模式串P="acac"，其部分匹配表的计算过程如下（i表示字符串下标）：（1）当i=0时，串为"a"，不存在真前缀和真后缀，因此长度为0；（2）当i=1时，串为"ac"，真前缀为{"a"}，真后缀为{"c"}，交集为空，因此长度为0；（3）当i=2时，串为"aca"，真前缀为{"a","ac"}，真后缀为{"a","ac"}，交集为{"a"}，因此长度为1；（4）当i=3时，串为"acac"，真前缀为{"a","ac","aca"}，真后缀{"c","ac","cac"}，交集为{"ac"}，因此长度为2。最终形成的部分匹配表为[0, 0, 1, 2]。</p><p>注意：<em>部分匹配表由模式串确定，与主串无关</em>。</p><h3 id="基本思想">基本思想</h3><p>已知条件：主串t、模式串p及next数组</p><p>首先定义两个指针i和j，指针i指向主串的第一个字符、指针j指向模式串的第一个字符。判断i和j所指的字符是否相等，如果相等，则将i和j均向后移动一位，继续进行判断；如果不相等，则出现失配，需要根据数组中next[j-1]的值回溯指针j，继续进行判断，在这一步中当<code>j==0</code>时，则不能继续进行回溯。当j等于模式串p的长度时，说明匹配成功，返回起始位置<code>i - j</code>。</p><p>代码： <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public static <span class="hljs-built_in">int</span> kmp(String t, String p)&#123;<br>    <span class="hljs-built_in">int</span> n = t.length<span class="hljs-literal">()</span>;<br>    <span class="hljs-built_in">int</span> m = p.length<span class="hljs-literal">()</span>;<br>    <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span><span class="hljs-literal">[<span class="hljs-identifier">m</span>]</span>;<br>    get<span class="hljs-constructor">Next(<span class="hljs-params">p</span>, <span class="hljs-params">next</span>)</span>;<br>    <span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i &lt; n)&#123;<br>        <span class="hljs-keyword">while</span>(j &gt; <span class="hljs-number">0</span><span class="hljs-operator"> &amp;&amp; </span>t.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span>)</span> != p.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">j</span>)</span>)&#123;<br>            j = next<span class="hljs-literal">[<span class="hljs-identifier">j</span>-<span class="hljs-number">1</span>]</span>;  <span class="hljs-comment">//对指针j进行回溯</span><br>        &#125;<br><br>        <span class="hljs-comment">//存在两种情况，j==0或者i和j所指字符相等</span><br>        <span class="hljs-comment">//如果i和j所指字符相等，则i和j均向后移动一位</span><br>        <span class="hljs-comment">//如果不相等，则说明j==0，需要i向后移动一位</span><br>        <span class="hljs-keyword">if</span>(t.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span>)</span><span class="hljs-operator"> == </span>p.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">j</span>)</span>)&#123;<br>            j++;<br>        &#125;<br>        i++;<br>        <span class="hljs-keyword">if</span>(j<span class="hljs-operator"> == </span>m) return i - j;<br>    &#125;<br>    return -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="pmt表的构建">PMT表的构建</h3><p>KMP算法的难点和核心在于构造部分匹配表PMT。</p><p>定义两个指针i和j，i从1开始，j从0开始。其中j指向当前最长真前缀的后一个字符，即<code>P[0: j]</code>为真前缀（不包含j所指元素），也表示<em>最长真前缀真后缀长度</em>；i指向最长真后缀中的最后一个字符。</p><p>判断i和j所指的字符是否相等，如果相等，则说明<strong>在当前部分字符串中，可以在当前最长真前缀的基础上形成一个更长的真前缀</strong>，j向右移动一位，并将next[i]置为j，i向右移动一位，继续进行判断；如果不相等，则需要根据next[j-1]对指针j进行回溯，继续进行判断，在这一步中当<code>j==0</code>时，则不能继续进行回溯。</p><p>代码： <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public static void get<span class="hljs-constructor">Next(String <span class="hljs-params">p</span>, <span class="hljs-params">int</span>[] <span class="hljs-params">next</span>)</span>&#123;<br>    <span class="hljs-built_in">int</span> m = p.length<span class="hljs-literal">()</span>;<br>    next<span class="hljs-literal">[<span class="hljs-number">0</span>]</span> = <span class="hljs-number">0</span>; <br>    <span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++)&#123;<br>        <span class="hljs-keyword">while</span>(j &gt; <span class="hljs-number">0</span><span class="hljs-operator"> &amp;&amp; </span>p.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span>)</span> != p.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">j</span>)</span>)&#123;<br>            j = next<span class="hljs-literal">[<span class="hljs-identifier">j</span>-<span class="hljs-number">1</span>]</span>;  <span class="hljs-comment">//对指针j进行回溯</span><br>        &#125;<br>        <span class="hljs-keyword">if</span>(p.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span>)</span><span class="hljs-operator"> == </span>p.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">j</span>)</span>)&#123;<br>            next<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = ++j;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>总的时间复杂度O(m+n)，其中n为主串的长度，m为模式串的长度。</p><p>参考资料:</p><ol type="1"><li><ahref="https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm">Knuth–Morris–Pratt_algorithm</a></li><li><ahref="https://www.youtube.com/watch?reload=9&amp;v=GTJr8OvyEVQ&amp;list=LLe_gEtrHWO_KN1wZOpQT4">Knuth–Morris–Pratt(KMP)Pattern Matching(Substring search)</a></li><li><ahref="https://blog.csdn.net/qq_40772692/article/details/80036959">KMP算法详解</a></li><li><ahref="https://blog.csdn.net/DADONGOOO/article/details/128761315">算法(一)|九千字硬核讲解KMP算法，搞懂KMP的来龙去脉</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>排序算法-非比较排序</title>
    <link href="/posts/25823/"/>
    <url>/posts/25823/</url>
    
    <content type="html"><![CDATA[<h2 id="计数排序">计数排序</h2><p>计数排序是一种非比较排序算法，采用了<strong>哈希</strong>思想。</p><p>算法思路： 1. 找出待排序序列的最大值和最小值，确定序列元素的范围。 2.创建一个计数数组用来统计序列中每个元素的出现次数。 3.采用<strong>前缀和</strong>思想对计数数组进行修改，获得每个元素最终位置的右边界。4.<strong>从右向左</strong>遍历待排序序列，根据前缀和数组确定当前元素的最终位置。</p><p>代码： <figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs glsl">public static <span class="hljs-type">void</span> countSort(<span class="hljs-type">int</span>[] arr)&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-built_in">min</span> = arr[<span class="hljs-number">0</span>], <span class="hljs-built_in">max</span> = arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">length</span>; i++)&#123;<br>        <span class="hljs-keyword">if</span>(arr[i] &lt; <span class="hljs-built_in">min</span>)&#123;<br>            <span class="hljs-built_in">min</span> = arr[i];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(arr[i] &gt; <span class="hljs-built_in">max</span>)&#123;<br>            <span class="hljs-built_in">max</span> = arr[i];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">int</span>[] cnt = new <span class="hljs-type">int</span> [<span class="hljs-built_in">max</span> - <span class="hljs-built_in">min</span> + <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">//统计每个元素出现的次数</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">length</span>; i++)&#123;<br>        cnt[arr[i] - <span class="hljs-built_in">min</span>] ++;<br>    &#125;<br><br>    <span class="hljs-comment">//对计数数组进行修改，获得每个元素的右边界</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; cnt.<span class="hljs-built_in">length</span>; i++)&#123;<br>        cnt[i] += cnt[i<span class="hljs-number">-1</span>];<br>    &#125;<br>    <br>    <span class="hljs-type">int</span>[] newArr = new <span class="hljs-type">int</span>[arr.<span class="hljs-built_in">length</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = arr.<span class="hljs-built_in">length</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>        newArr[--cnt[arr[i] - <span class="hljs-built_in">min</span>]] = arr[i];<br>    &#125;<br><br>    System.arraycopy(newArr, <span class="hljs-number">0</span>, arr, <span class="hljs-number">0</span>, arr.<span class="hljs-built_in">length</span>);<br>&#125;<br></code></pre></td></tr></table></figure></p><p>时间复杂度为O(n+k)，空间复杂度为O(n+k)，其中<code>k = max - min + 1</code>，是一种<strong>稳定</strong>排序算法。</p><h2 id="桶排序">桶排序</h2><p>桶排序也称为箱排序，是一种非比较排序算法。</p><p>算法思路：将待排序序列的数据范围划分为若干个子区间，每一个子区间相当于一个桶。将待排序元素分散到这些桶中，这一过程称为<strong>分配</strong>。然后，对每个桶分别进行排序，可以使用其他排序算法或者递归使用桶排序。最后按照桶的顺序，对每个桶中的元素进行合并，这一过程称为<strong>收集</strong>，最终获得有序序列。如图所示。</p><figure><img src="/images/sort/桶排序.png" alt="桶排序" /><figcaption aria-hidden="true">桶排序</figcaption></figure><p>桶排序适用于<strong>待排序序列中元素分布比较均匀</strong>的情况。</p><h2 id="基数排序">基数排序</h2><p>基数排序是一种<strong>分配式排序</strong>，使用了<strong>桶排序</strong>的思想。它可以分为最高位优先（MSD）和最低位优先（LSD）两种。最高位优先就是先按照每一个元素最高位进行排序，然后依次对低位进行排序；最低位优先则是先按照每一个元素最低位进行排序，然后依次对高位进行排序。通常使用最低位优先。</p><p>算法思路：从最低位（即个位）开始，按照十位、百位……最高位的顺序，依次对所有位进行排序，排序过程包括以下两步：<strong>1.分配</strong>：按照当前位将数据分到相应的桶中，不考虑其他位。<strong>2.收集</strong>：将所有桶中的数据进行合并，合并过程按照<strong>先进先出</strong>的原则进行。</p><p>代码： <figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">radixSort</span>(<span class="hljs-type">int</span>[] arr)&#123;<br>    <span class="hljs-comment">//找出数组中的最大值</span><br>    <span class="hljs-type">int</span> <span class="hljs-built_in">max</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++)&#123;<br>        <span class="hljs-keyword">if</span>(arr[i] &gt; <span class="hljs-built_in">max</span>)&#123;<br>            <span class="hljs-built_in">max</span> = arr[i];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//获取最大位数</span><br>    <span class="hljs-type">int</span> digit = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">max</span> !=<span class="hljs-number">0</span> )&#123;<br>        digit++;<br>        <span class="hljs-built_in">max</span> /= <span class="hljs-number">10</span>;<br>    &#125;<br><br>    List&lt;LinkedList&lt;Integer&gt;&gt; buckets = <span class="hljs-keyword">new </span><span class="hljs-class title_">ArrayList</span>&lt;&gt;(<span class="hljs-number">10</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)&#123;<br>        buckets.<span class="hljs-property">add</span>(<span class="hljs-keyword">new </span><span class="hljs-class title_">LinkedList</span>&lt;&gt;());<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-built_in">exp</span> = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(digit != <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">//分配</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++)&#123;<br>            buckets.<span class="hljs-property">get</span>((arr[i] / <span class="hljs-built_in">exp</span>)%<span class="hljs-number">10</span>).<span class="hljs-property">add</span>(arr[i]);<br>        &#125;<br><br>        <span class="hljs-comment">//收集</span><br>        <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(LinkedList&lt;Integer&gt; bucket : buckets)&#123;<br>            <span class="hljs-keyword">while</span>(!bucket.<span class="hljs-property">isEmpty</span>())&#123;<br>                arr[j++] = bucket.<span class="hljs-property">removeFirst</span>();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-built_in">exp</span> *= <span class="hljs-number">10</span>;<br>        digit--;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>时间复杂度为O(d*(n+k))，空间复杂度为O(n+k)，是一种<strong>稳定</strong>排序算法，其中d为最大值的位数，k为数字的<strong>基数</strong>（即桶的个数）。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>排序算法-选择排序与堆排序</title>
    <link href="/posts/4754/"/>
    <url>/posts/4754/</url>
    
    <content type="html"><![CDATA[<h2 id="选择排序">选择排序</h2><p>算法思路：找出待排序序列中最小的元素与序列的第一个元素进行交换，此时序列第一个元素为整个待排序序列的最小值。对剩余未排序元素重复这一过程，直到所有元素均有序。每进行一次交换，便有一个元素确定了最终的位置。</p><p>代码： <figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">selectSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span>; i++)&#123;<br>        <span class="hljs-type">int</span> min = i; <span class="hljs-comment">// 记录最小值的下标</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; arr.length; j++)&#123;<br>            <span class="hljs-keyword">if</span>(arr[j] &lt; arr[min])&#123;<br>                min = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(min != i)&#123;<br>            <span class="hljs-type">int</span> tmp = arr[i];<br>            arr[i] = arr[min];<br>            arr[min] = tmp;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>时间复杂度为O(n^2)，空间复杂度为O(1)，是一种<strong>不稳定</strong>排序算法。</p><h2 id="堆排序">堆排序</h2><p>堆排序是利用<strong>堆</strong>（heap）这种数据结构设计的一种排序算法，是<strong>选择排序</strong>的一种。</p><h3 id="堆">堆</h3><p>堆是一种特殊的<strong>完全二叉树</strong>，它满足如下性质：<strong>任意子树父节点的值大于（或小于）子节点的值</strong>。当父节点的值大于子节点的值，称为<strong>大根堆</strong>；当父节点的值小于子节点的值，称为<strong>小根堆</strong>。</p><p>补充：具有n个节点的完全二叉树的性质： 1.一个节点的下标为i（0&lt;=i&lt;=n-1）：（1）如果<code>2*i+1 &lt; n</code>，则该节点存在左孩子，其下标为<code>2*i+1</code>；（2）如果<code>2*i+2 &lt; n</code>，则该节点存在右孩子，其下标为<code>2*i+2</code>。2. 非叶子节点的下标范围为[0,n/2 -1]， 叶子节点的下标范围为[n/2,n-1]（注意下标均为整数）。</p><h3 id="基本思想">基本思想</h3><p>算法思路：设序列中的元素数目为n。将序列构建成一个堆，然后将堆顶元素与末尾元素交换，此时末尾元素即为序列的最大值。重新调整堆的结构，使剩余n-1个元素其满足堆的定义。重复上述过程，直到所有元素均有序。</p><p>通常，升序排序使用大根堆，降序排序使用小根堆。下面以大根堆为例进行说明。</p><p><strong>步骤一：建堆</strong></p><p>从最后一个非叶子节点（下标为n/2-1）开始进行调整，然后<strong>自下而上</strong>、<strong>自右向左</strong>找出所有的非叶子节点进行调整。</p><p>调整的过程就是判断父节点的值是否大于子节点，如果存在子节点的值大于父节点的情况，则将子节点中的最大值与父节点进行交换，并对进行交换的子节点所在的子树进行<strong>递归</strong>（或迭代）调整。</p><p><strong>步骤二：排序</strong></p><p>将堆顶元素与待排序序列末尾元素进行交换，此时末尾元素为整个待排序序列的最大值。然后调整堆，得到新的堆顶元素。每进行一次交换，便有一个元素确定了最终的位置。经过n-1次交换，所有元素完成排序。</p><p>完整代码（堆调整递归）： <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public static void adjust<span class="hljs-constructor">Heap(<span class="hljs-params">int</span>[] <span class="hljs-params">arr</span>, <span class="hljs-params">int</span> <span class="hljs-params">i</span>, <span class="hljs-params">int</span> <span class="hljs-params">n</span>)</span>&#123;<br>    <span class="hljs-built_in">int</span> lChild = <span class="hljs-number">2</span><span class="hljs-operator"> * </span>i + <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">int</span> rChild = <span class="hljs-number">2</span><span class="hljs-operator"> * </span>i + <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">int</span> target = i;<br>    <span class="hljs-keyword">if</span>(lChild &lt; n<span class="hljs-operator"> &amp;&amp; </span>arr<span class="hljs-literal">[<span class="hljs-identifier">lChild</span>]</span> &gt; arr<span class="hljs-literal">[<span class="hljs-identifier">target</span>]</span>)&#123;<br>        target = lChild;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(rChild &lt; n<span class="hljs-operator"> &amp;&amp; </span>arr<span class="hljs-literal">[<span class="hljs-identifier">rChild</span>]</span> &gt; arr<span class="hljs-literal">[<span class="hljs-identifier">target</span>]</span>)&#123;<br>        target = rChild;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(target != i)&#123;<br>        swap(arr, i, target);<br>        adjust<span class="hljs-constructor">Heap(<span class="hljs-params">arr</span>, <span class="hljs-params">target</span>, <span class="hljs-params">n</span>)</span>; <span class="hljs-comment">// 调整对应的子树</span><br>    &#125;<br>&#125;<br><br>public static void swap(<span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> arr, <span class="hljs-built_in">int</span> i, <span class="hljs-built_in">int</span> j)&#123;<br>    <span class="hljs-built_in">int</span> tmp = arr<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>;<br>    arr<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = arr<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>;<br>    arr<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span> = tmp;<br>&#125;<br><br>public static void build<span class="hljs-constructor">Heap(<span class="hljs-params">int</span>[] <span class="hljs-params">arr</span>, <span class="hljs-params">int</span> <span class="hljs-params">n</span>)</span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = n<span class="hljs-operator"> / </span><span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>        adjust<span class="hljs-constructor">Heap(<span class="hljs-params">arr</span>, <span class="hljs-params">i</span>, <span class="hljs-params">n</span>)</span>;<br>    &#125;<br>&#125;<br><br>public static void heap<span class="hljs-constructor">Sort(<span class="hljs-params">int</span>[] <span class="hljs-params">arr</span>)</span>&#123;<br><br>    <span class="hljs-built_in">int</span> n = arr.length;<br><br>    <span class="hljs-comment">//构建大根堆</span><br>    build<span class="hljs-constructor">Heap(<span class="hljs-params">arr</span>, <span class="hljs-params">n</span>)</span>;<br><br>    <span class="hljs-comment">//将堆顶元素（即最大值）与待排序序列末尾元素交换，并调整堆</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = arr.length - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--)&#123;<br>        swap(arr, i , <span class="hljs-number">0</span>);<br>        adjust<span class="hljs-constructor">Heap(<span class="hljs-params">arr</span>, 0, <span class="hljs-params">i</span>)</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>堆调整非递归代码： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">adjustHeap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>; k &lt; n; k = <span class="hljs-number">2</span> * k + <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-comment">// k是最大子节点的下标</span><br>        <span class="hljs-keyword">if</span>(k + <span class="hljs-number">1</span> &lt; n &amp;&amp; arr[k] &lt; arr[k+<span class="hljs-number">1</span>])&#123; <span class="hljs-comment">//右孩子存在且值大于左孩子</span><br>            k++;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(arr[k] &gt; arr[i])&#123;<br>            <span class="hljs-built_in">swap</span>(arr, i, k);<br>            i = k;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>时间复杂度为O(nlogn)，空间复杂度为O(1)，是一种<strong>不稳定</strong>排序算法。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>排序算法-归并排序与快速排序</title>
    <link href="/posts/29757/"/>
    <url>/posts/29757/</url>
    
    <content type="html"><![CDATA[<h2 id="分治法">分治法</h2><p>分治思想：对于一个难以解决的问题，将其划分为规模较小的子问题，这些子问题<strong>相互独立</strong>并且与原问题具有<strong>相同形式</strong>，递归求解子问题，然后将各子问题的解合并形成原问题的解。</p><p>分治法分为三个步骤： 1.分：将大问题分解为若干子问题2.治：递归求解各个子问题（将子问题分为规模更小的问题，直到问题可以直接求解）3.合：将子问题的解合并为原问题的解</p><h2 id="归并排序">归并排序</h2><p>归并排序是<strong>分治</strong>法的一个典型应用。</p><p>算法思路： 1.分：将一个序列的排序问题转化为m个子序列的排序问题2.治：以递归（或者迭代）形式，分别对m个子序列进行归并排序3.合：将m个有序子序列进行合并，形成一个有序序列</p><p>当m=2时，即为<strong>二路归并排序</strong>，其代码（递归形式）如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public static void merge<span class="hljs-constructor">Sort(<span class="hljs-params">int</span>[] <span class="hljs-params">arr</span>, <span class="hljs-params">int</span> <span class="hljs-params">low</span>, <span class="hljs-params">int</span> <span class="hljs-params">high</span>, <span class="hljs-params">int</span>[] <span class="hljs-params">tmp</span>)</span>&#123;<br>    <span class="hljs-keyword">if</span>(low &lt; high) &#123;<br>        <span class="hljs-built_in">int</span> mid = (low + high)<span class="hljs-operator"> / </span><span class="hljs-number">2</span>;<br><br>        <span class="hljs-comment">//将序列划分为两个子序列，分别进行归并排序</span><br>        merge<span class="hljs-constructor">Sort(<span class="hljs-params">arr</span>, <span class="hljs-params">low</span>, <span class="hljs-params">mid</span>, <span class="hljs-params">tmp</span>)</span>;<br>        merge<span class="hljs-constructor">Sort(<span class="hljs-params">arr</span>, <span class="hljs-params">mid</span> + 1, <span class="hljs-params">high</span>, <span class="hljs-params">tmp</span>)</span>;<br><br>        <span class="hljs-comment">//合并两个有序子序列</span><br>        merge(arr, low, mid, high, tmp);<br>    &#125;<br>&#125;<br><br>public static void merge(<span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> arr, <span class="hljs-built_in">int</span> low, <span class="hljs-built_in">int</span> mid, <span class="hljs-built_in">int</span> high, <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> tmp)&#123;<br>    <span class="hljs-built_in">int</span> i = low, j = mid + <span class="hljs-number">1</span>, k = low;<br>    <span class="hljs-keyword">while</span>(i &lt;= mid<span class="hljs-operator"> &amp;&amp; </span>j &lt;= high)&#123;<br>        <span class="hljs-keyword">if</span>(arr<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> &lt;= arr<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>)&#123;<br>            tmp<span class="hljs-literal">[<span class="hljs-identifier">k</span><span class="hljs-operator">++</span>]</span> = arr<span class="hljs-literal">[<span class="hljs-identifier">i</span><span class="hljs-operator">++</span>]</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            tmp<span class="hljs-literal">[<span class="hljs-identifier">k</span><span class="hljs-operator">++</span>]</span> = arr<span class="hljs-literal">[<span class="hljs-identifier">j</span><span class="hljs-operator">++</span>]</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(i &lt;= mid)&#123;<br>        tmp<span class="hljs-literal">[<span class="hljs-identifier">k</span><span class="hljs-operator">++</span>]</span> = arr<span class="hljs-literal">[<span class="hljs-identifier">i</span><span class="hljs-operator">++</span>]</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(j &lt;= high)&#123;<br>        tmp<span class="hljs-literal">[<span class="hljs-identifier">k</span><span class="hljs-operator">++</span>]</span> = arr<span class="hljs-literal">[<span class="hljs-identifier">j</span><span class="hljs-operator">++</span>]</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> m = low ; m &lt;= high; m++)&#123;<br>        arr<span class="hljs-literal">[<span class="hljs-identifier">m</span>]</span> = tmp<span class="hljs-literal">[<span class="hljs-identifier">m</span>]</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：辅助数组tmp需要预先创建，不能在函数mergeSort中创建，否则每一次递归都会创建一个新的辅助数组。</p><p>时间复杂度为O(nlogn)，空间复杂度为O(n)，是一种<strong>稳定</strong>排序算法。</p><h2 id="快速排序">快速排序</h2><h3 id="基本思想">基本思想</h3><p>快速排序是对冒泡排序的改进，采用了<strong>分治</strong>思想。</p><p>算法思路：从序列中任选一个基准元素pivot，将序列按照pivot划分为两部分，即<strong>分区操作</strong>(partition)，左侧部分均小于等于基准元素pivot，右侧部分均大于等于基准元素，然后分别对这两个部分进行递归求解，最终形成有序序列。</p><p>经过一次分区操作，便有一个基准元素确定了最终的位置。实现分区操作的方法有多种，这里给出了两种方法，其中均选择序列第一个元素作为基准元素。</p><h3 id="挖坑法">“挖坑法”</h3><p>实现思路：选定pivot后，其原始位置相当于空白。设定left和right分别表示序列首部和末尾。从右向左找小于pivot的元素，并将该元素与空白进行交换；然后从左向右找大于pivot的元素，并将该元素与空白进行交换。交替执行上述过程，逐渐缩小范围，直到left==right，此时left处即为pivot的最终位置（left左侧元素均小于等于pivot，right右侧元素均大于等于pivot）。</p><p>代码： <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public static void quick<span class="hljs-constructor">Sort(<span class="hljs-params">int</span>[] <span class="hljs-params">arr</span>, <span class="hljs-params">int</span> <span class="hljs-params">low</span>, <span class="hljs-params">int</span> <span class="hljs-params">high</span>)</span>&#123;<br>    <span class="hljs-keyword">if</span>(low &lt; high)&#123;<br>        <span class="hljs-built_in">int</span> i = partition(arr, low, high);<br>        quick<span class="hljs-constructor">Sort(<span class="hljs-params">arr</span>, <span class="hljs-params">low</span>, <span class="hljs-params">i</span>-1)</span>;<br>        quick<span class="hljs-constructor">Sort(<span class="hljs-params">arr</span>, <span class="hljs-params">i</span>+1, <span class="hljs-params">high</span>)</span>;<br>    &#125;<br>&#125;<br><br>public static <span class="hljs-built_in">int</span> partition(<span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> arr, <span class="hljs-built_in">int</span> low ,<span class="hljs-built_in">int</span> high)&#123;<br>    <span class="hljs-built_in">int</span> pivot = arr<span class="hljs-literal">[<span class="hljs-identifier">low</span>]</span>;<br>    <span class="hljs-built_in">int</span> left = low;<br>    <span class="hljs-built_in">int</span> right = high;<br>    <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>        <span class="hljs-comment">//从右向左找比pivot小的元素</span><br>        <span class="hljs-keyword">while</span>(left &lt; right<span class="hljs-operator"> &amp;&amp; </span>arr<span class="hljs-literal">[<span class="hljs-identifier">right</span>]</span> &gt;= pivot)&#123;<br>            right--; <span class="hljs-comment">// right右侧元素均大于等于pivot</span><br>        &#125;<br>        arr<span class="hljs-literal">[<span class="hljs-identifier">left</span>]</span> = arr<span class="hljs-literal">[<span class="hljs-identifier">right</span>]</span>;<br><br>        <span class="hljs-comment">//从左向右找比pivot大的元素</span><br>        <span class="hljs-keyword">while</span>(left &lt; right<span class="hljs-operator"> &amp;&amp; </span>arr<span class="hljs-literal">[<span class="hljs-identifier">left</span>]</span> &lt;= pivot) &#123;<br>            left++; <span class="hljs-comment">// left左侧元素均小于等于pivot</span><br>        &#125;<br>        arr<span class="hljs-literal">[<span class="hljs-identifier">right</span>]</span> = arr<span class="hljs-literal">[<span class="hljs-identifier">left</span>]</span>;<br>    &#125;<br>    arr<span class="hljs-literal">[<span class="hljs-identifier">left</span>]</span> = pivot;<br>    return left;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><strong>注意</strong>：判断条件<code>while(left &lt; right &amp;&amp; arr[right] &gt;= pivot)</code>和<code>while(left &lt; right &amp;&amp; arr[left] &lt;= pivot)</code>中至少有一个含有等号。如果不加等号，则在含有重复元素的情况下会出现死循环，比如当前right位置的元素值等于pivot，则将right处元素赋值给left处元素，然后判断left处元素不小于pivot，再将left处元素赋值给right处元素，从而left和right处元素一直交换，形成死循环。</p><h3 id="快慢指针法">快慢指针法</h3><p>实现思路：分别设置快指针cur和慢指针pre。cur向右查找小于pivot的元素，pre向右移动一位，将该元素与pre处的元素进行交换。当cur查完整个序列时，pre即为基准元素pivot的最终位置（pre及其左侧（不包含low处元素）均为小于pivot的元素，pre右侧到cur左侧均为大于等于pivot的元素）。如图所示。</p><figure><img src="/images/sort/快速排序-快慢指针法.png" alt="快慢指针法" /><figcaption aria-hidden="true">快慢指针法</figcaption></figure><p>代码： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">partition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> low ,<span class="hljs-type">int</span> high)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">pivot</span> <span class="hljs-operator">=</span> arr[low];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> low;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> pre + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(cur &lt;= high)&#123;<br>        <span class="hljs-keyword">if</span>(arr[cur] &lt; pivot)&#123;<br>            pre++;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> arr[pre];<br>            arr[pre] = arr[cur];<br>            arr[cur] = tmp;<br>        &#125;<br>        cur++;<br>    &#125;<br>    arr[low] = arr[pre];<br>    arr[pre] = pivot;<br>    <span class="hljs-keyword">return</span> pre;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><strong>注意</strong>：最后需要将pre与low处的基准元素进行交换，不能遗漏。</p><h3 id="优化与分析">优化与分析</h3><p>快速排序的时间性能取决于基准元素pivot的选择。如果每次都选择最小或者最大的元素作为基准元素，则快速排序的时间复杂度会退化为为O(n^2)。为了减少最坏情况下的时间复杂度，通常使用“三数取中法”选择基准元素。</p><p>“<strong>三数取中法</strong>”：比较序列首部、末尾和中间元素，选择中间值作为基准元素。</p><p>时间复杂度为O(nlogn)，空间复杂度为O(logn)，是一种<strong>不稳定</strong>排序算法。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>排序算法-插入排序与希尔排序</title>
    <link href="/posts/1110/"/>
    <url>/posts/1110/</url>
    
    <content type="html"><![CDATA[<h2 id="插入排序">插入排序</h2><h3 id="基本思想">基本思想</h3><p>算法思路：将当前序列分为有序和待排序（无序）两部分，找到每一个待排序元素在有序序列中的位置，将其插入到有序序列中，并将之后的所有元素向后移动一个单位，形成一个新的有序序列。重复这一过程，直到所有元素均有序。初始时将第一个元素视为有序序列。如图所示。</p><figure><img src="/images/sort/插入排序.png" alt="插入排序" /><figcaption aria-hidden="true">插入排序</figcaption></figure><p>代码： <figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">insertSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt; arr.length; i++)&#123;<br>        <span class="hljs-comment">// i左侧的元素均处于有序状态</span><br>        <span class="hljs-type">int</span> tmp = arr[i];<br>        <span class="hljs-type">int</span> j = i<span class="hljs-number">-1</span>; <br>        <span class="hljs-keyword">while</span>(j &gt;= <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>(tmp &lt; arr[j])&#123;<br>                <span class="hljs-comment">// 如果待插入元素的值小于j处元素，则将j处元素向后移动一个位置</span><br>                arr[j+<span class="hljs-number">1</span>] = arr[j];<br>                j--;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 如果待插入元素的值大于等于j处元素，则j+1即表示待插入位置</span><br>        &#125;<br>        arr[j+<span class="hljs-number">1</span>] = tmp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>时间复杂度O(n^2)，空间复杂度O(1)，是一种<strong>稳定</strong>排序算法。在<strong>局部有序</strong>的情况下，效率较高；而在数据完全无序的情况下，效率很低。</p><h3 id="二分插入排序">二分插入排序</h3><p>算法思路:在直接插入排序的基础上，使用<strong>二分查找</strong>算法找出待插入元素在<strong>有序</strong>序列中的位置，如果存在重复元素，则需要找出其<strong>右边界</strong>。</p><p>代码： <figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs excel">public static void binaryInsertSort(<span class="hljs-built_in">int</span>[] arr)&#123;<br>    for(<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt; arr.length; i++)&#123;<br>        // i左侧的元素均处于有序状态<br><br>        //二分查找找出待插入位置<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span> = <span class="hljs-number">0</span>, <span class="hljs-built_in">right</span> = i-<span class="hljs-number">1</span>;<br>        while(<span class="hljs-built_in">left</span> &lt;= <span class="hljs-built_in">right</span>)&#123;<br>            <span class="hljs-built_in">int</span> <span class="hljs-built_in">mid</span> = (<span class="hljs-built_in">left</span> + <span class="hljs-built_in">right</span>) / <span class="hljs-number">2</span>;<br>            <span class="hljs-built_in">if</span>(arr[<span class="hljs-built_in">mid</span>] &lt;= arr[i]) <span class="hljs-built_in">left</span> = <span class="hljs-built_in">mid</span> + <span class="hljs-number">1</span>;<br>            else <span class="hljs-built_in">right</span> = <span class="hljs-built_in">mid</span> - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-built_in">int</span> target = <span class="hljs-built_in">left</span>;<br>        <span class="hljs-built_in">int</span> tmp = arr[i];<br>        for(<span class="hljs-built_in">int</span> j = i-<span class="hljs-number">1</span>; j &gt;= target; j--)&#123;<br>            arr[j+<span class="hljs-number">1</span>] = arr[j];<br>        &#125;<br>        arr[target] = tmp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>二分插入排序减少了比较次数，在特定的情况下提高了排序效率。然而其时间复杂度仍然为O(n^2)，是一种<strong>稳定</strong>排序算法。</p><h2 id="希尔排序">希尔排序</h2><p>希尔排序是插入排序的一种，又称缩小增量排序。</p><p>算法思路：给定增量gap，将下标为i + k * gap 的元素分为一组(其中k =1,2,3……n 且 i = 0,1,2…… gap-1 且 i + k * gap &lt;序列长度L)，一共分为gap组。对每一个分组分别使用<strong>直接插入排序</strong>，缩减增量值，重复这一过程。当增量值为1时，所有元素为一组进行直接插入排序，算法终止，所有元素均有序。如图所示。</p><figure><img src="/images/sort/希尔排序.png" alt="希尔排序" /><figcaption aria-hidden="true">希尔排序</figcaption></figure><p>注意：关于最优增量序列的选择至今尚未解决，通常情况下，选择初始增量为序列长度L的一半，增量值每一轮减半。</p><p>代码： <figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">shellSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span></span>&#123;<br>    <span class="hljs-type">int</span> gap = arr.length / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">while</span>(gap != <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; gap; i++)&#123;<br>            <span class="hljs-comment">// 同一组元素进行直接插入排序</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i + gap; j &lt; arr.length; j += gap)&#123;<br>                <span class="hljs-type">int</span> tmp = arr[j];<br>                <span class="hljs-type">int</span> k = j - gap;<br>                <span class="hljs-keyword">while</span>(k &gt;= <span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-keyword">if</span>(tmp &lt; arr[k])&#123;<br>                        arr[k + gap] = arr[k];<br>                        k -= gap;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>                &#125;<br>                arr[k + gap] = tmp;<br>            &#125;<br>        &#125;<br>        gap /= <span class="hljs-number">2</span>; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>希尔排序的时间复杂度目前尚未研究清楚，其执行时间依赖于增量序列，但是其时间性能优于直接插入排序，空间复杂度是O(1)，是一种<strong>不稳定</strong>排序算法。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>排序算法-冒泡排序</title>
    <link href="/posts/61237/"/>
    <url>/posts/61237/</url>
    
    <content type="html"><![CDATA[<h2 id="冒泡排序">冒泡排序</h2><p>算法思路：以升序为例，依次比较相邻两个元素，如果第一个元素的值大于第二个元素，则交换两个元素的值，直到处理完序列中最后两个元素，即为一轮，此时最后一个元素的值即为最大值（即处于有序状态）。重复这一过程，直到所有元素都处于有序状态。如图所示。</p><figure><img src="/images/sort/冒泡排序.png" alt="冒泡排序" /><figcaption aria-hidden="true">冒泡排序</figcaption></figure><p>代码（java）： <figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = arr.length<span class="hljs-number">-1</span>; i &gt; <span class="hljs-number">0</span>; i--)&#123;<br>        <span class="hljs-comment">// i后面的元素均处于有序状态</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++)&#123;<br>            <span class="hljs-keyword">if</span>(arr[j] &gt; arr[j+<span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-type">int</span> tmp = arr[j];<br>                arr[j] = arr[j+<span class="hljs-number">1</span>];<br>                arr[j+<span class="hljs-number">1</span>] = tmp;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>时间复杂度O(n^2)，空间复杂度O(1)，是一种<strong>稳定</strong>排序算法。</p><h2 id="冒泡排序的改进">冒泡排序的改进</h2><p>如果在某一轮中没有发生元素值的交换，则说明序列已经处于有序状态，无需再继续进行循环。设置一个标记flag=true，只要发生元素值的交换就将flag置为false。在一轮结束后，如果flag仍然为true，则说明序列已经有序，终止循环。</p><p>改进后的代码： <figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">bubbleSortImprove</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = arr.length<span class="hljs-number">-1</span>; i &gt; <span class="hljs-number">0</span>; i--)&#123;<br>        <span class="hljs-comment">// i后面的元素均处于有序状态</span><br>        <span class="hljs-type">boolean</span> flag = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 标记序列是否有序</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++)&#123;<br>            <span class="hljs-keyword">if</span>(arr[j] &gt; arr[j+<span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-type">int</span> tmp = arr[j];<br>                arr[j] = arr[j+<span class="hljs-number">1</span>];<br>                arr[j+<span class="hljs-number">1</span>] = tmp;<br>                flag = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(flag) <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="双向冒泡排序">双向冒泡排序</h2><p>双向冒泡排序，又称鸡尾酒排序，是冒泡排序的一种改进。</p><p>算法步骤：1.从左到右依次比较相邻的两个元素，直到将最大值移动至序列末尾。2.从右向左依次比较相邻的两个元素，直到将最小值移动至序列头部。3.重复上述过程，直到序列中只剩一个元素，即完成排序。</p><p>代码： <figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">cocktailSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span></span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = arr.length<span class="hljs-number">-1</span>;<br>    <span class="hljs-comment">//left左侧和right右侧的元素均处于有序状态</span><br>    <span class="hljs-type">boolean</span> flag = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br><br>        flag = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-comment">//从左向右移动最大值至right处</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = left; i &lt; right; i++)&#123;<br>            <span class="hljs-keyword">if</span>(arr[i] &gt; arr[i+<span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-type">int</span> tmp = arr[i];<br>                arr[i] = arr[i+<span class="hljs-number">1</span>];<br>                arr[i+<span class="hljs-number">1</span>] = tmp;<br>                flag = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        right--;<br><br>        <span class="hljs-comment">//从右向左移动最小值至left处</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = right; j &gt; left; j--)&#123;<br>            <span class="hljs-keyword">if</span>(arr[j<span class="hljs-number">-1</span>] &gt; arr[j])&#123;<br>                <span class="hljs-type">int</span> tmp = arr[j<span class="hljs-number">-1</span>];<br>                arr[j<span class="hljs-number">-1</span>] = arr[j];<br>                arr[j] = tmp;<br>                flag = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        left++;<br><br>        <span class="hljs-keyword">if</span>(flag) <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>基于Tensorflow的MNIST手写数字识别</title>
    <link href="/posts/42525/"/>
    <url>/posts/42525/</url>
    
    <content type="html"><![CDATA[<p>任务描述：识别给定图像中的数字，数字范围为0到9。实际上是一个<strong>多分类</strong>任务。</p><h3 id="mnist数据集">MNIST数据集</h3><p>图像的大小为28*28，标签范围为0到9，训练集图片的数量为60000，测试集图片的数量为10000。keras中提供了该数据集，能够直接导入使用。</p><h3 id="数据处理">数据处理</h3><p>1.对图像进行扁平化处理，将图像维度由28*28转化为行向量。2.进行归一化处理。对于图像数据，直接用像素值除以255。3.对于多分类任务，需要将标签转化为<strong>one-hot编码</strong>。</p><h3 id="模型结构">模型结构</h3><p>网络结构为三层，均为全连接层。前两层均为20个神经元，激活函数均为relu；最后一层为10个神经元（对应分类数目），激活函数使用softmax。</p><h3 id="模型训练">模型训练</h3><p>采用Adam算法进行梯度下降，损失函数选用交叉熵损失，评价指标选择准确率（accuracy）</p><p>代码如下： <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs routeros">import numpy as np<br>import tensorflow as tf<br><span class="hljs-keyword">from</span> tensorflow import keras<br><span class="hljs-keyword">from</span> keras.datasets import mnist<br><span class="hljs-keyword">from</span> keras.utils import to_categorical<br><span class="hljs-keyword">from</span> PIL import Image<br><br><span class="hljs-comment"># ----------------------</span><br><span class="hljs-comment"># 数据集处理</span><br><span class="hljs-comment"># ----------------------</span><br><br>(train_images, train_labels), (test_images, test_labels) = mnist.load_data()<br><span class="hljs-comment"># 数据格式为np.ndarray 图像形状为(num,28,28) 标签形状为(num,)</span><br><br><span class="hljs-comment"># img = Image.fromarray(test_images[2341])</span><br><span class="hljs-comment"># img.show()</span><br><span class="hljs-comment"># img.save(&quot;./images/image.jpg&quot;)</span><br><br><span class="hljs-comment"># 扁平化处理 </span><br>dim = train_images.shape[1] * train_images.shape[2] # 输入到网络中的数据的维度<br>train_images = train_images.reshape((train_images.shape[0], -1))<br>test_images = test_images.reshape((test_images.shape[0], -1))<br><br><span class="hljs-comment"># 归一化处理</span><br>train_images = train_images / 255<br>test_images = test_images / 255<br><br><span class="hljs-comment">#将标签转化为one-hot编码</span><br>train_labels = to_categorical(train_labels.reshape(-1,1), <span class="hljs-attribute">num_classes</span>=10)<br>test_labels = to_categorical(test_labels.reshape(-1,1), <span class="hljs-attribute">num_classes</span>=10)<br><br><span class="hljs-comment"># -----------------------</span><br><span class="hljs-comment"># 模型构建</span><br><span class="hljs-comment"># -----------------------</span><br><br>model = keras.models.Sequential([<br>    keras.layers.Dense(<span class="hljs-attribute">units</span>=20, input_shape=(dim, )),    # 全连接层<br>    keras.layers.ReLU(),<br>    keras.layers.Dense(<span class="hljs-attribute">units</span>=20),    # 全连接层<br>    keras.layers.ReLU(),<br>    keras.layers.Dense(<span class="hljs-attribute">units</span>=10,activation=&quot;softmax&quot;)  # 全连接+softmax<br>])<br><span class="hljs-comment"># model.summary() # 查看网络结构</span><br><br><span class="hljs-comment"># 模型装配</span><br>lr = 0.001<br>model.compile(<span class="hljs-attribute">optimizer</span>=keras.optimizers.Adam(learning_rate=lr),<br>              loss = keras.losses.CategoricalCrossentropy(),<br>              metrics=[<span class="hljs-string">&#x27;accuracy&#x27;</span>])<br><span class="hljs-comment"># 也可以使用字符串形式传递</span><br><span class="hljs-comment"># 如 optimizer = “rmsprop”, loss = &#x27;categorical_crossentropy&#x27;)</span><br><br><span class="hljs-comment"># 模型训练</span><br>num_epochs = 100<br>minibatch_size = 50<br>history = model.fit(train_images, train_labels, <span class="hljs-attribute">epochs</span>=num_epochs, <span class="hljs-attribute">batch_size</span>=minibatch_size)<br><br>train_loss = history.history[<span class="hljs-string">&#x27;loss&#x27;</span>]<br>train_accuracy = history.history[<span class="hljs-string">&#x27;accuracy&#x27;</span>]<br><br><span class="hljs-comment"># 在tensorboard中绘制loss曲线和accuracy曲线</span><br>log_dir = <span class="hljs-string">&quot;./logs/&quot;</span><br>writer = tf.summary.create_file_writer(log_dir)<br>with writer.as_default():<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(num_epochs):<br>        tf.summary.scalar(<span class="hljs-string">&#x27;train_loss&#x27;</span>, train_loss[i], <span class="hljs-attribute">step</span>=i)<br>        tf.summary.scalar(<span class="hljs-string">&#x27;accuracy&#x27;</span>, train_accuracy[i], <span class="hljs-attribute">step</span>=i)<br>writer.flush()<br>writer.close()<br><br><span class="hljs-comment"># 模型评估</span><br>_, test_accuracy = model.evaluate(test_images, test_labels)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;test accuracy:&quot;</span> + str(test_accuracy))<br><br><span class="hljs-comment"># 模型测试</span><br>image = Image.open(<span class="hljs-string">&quot;./images/image.jpg&quot;</span>)<br>image_array = np.array(image).reshape(1,-1)<br>result = model.predict(image_array)<br><span class="hljs-built_in">print</span>(result)<br></code></pre></td></tr></table></figure></p><p>在终端中使用<code>tensorboard --logdir=logs</code>，之后在localhost:6006端口（默认端口）即可查看绘制的曲线，如下图所示。</p><figure><img src="/images/deeplearning/tensorflow实现手写数字识别运行结果.png"alt="训练损失train_loss和准确率accuracy曲线" /><figcaptionaria-hidden="true">训练损失train_loss和准确率accuracy曲线</figcaption></figure><p>思考过程：数据集处理——网络搭建——模型改进</p><p>改进时可以调整层数、神经元数量、学习率、训练轮次等因素。对于该模型，增加神经元数量的提升效果最显著。</p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Anaconda常用命令</title>
    <link href="/posts/29299/"/>
    <url>/posts/29299/</url>
    
    <content type="html"><![CDATA[<h2 id="anaconda命令">anaconda命令</h2><ol type="1"><li>查看anaconda中的全部环境</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda <span class="hljs-built_in">env</span> list<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>创建虚拟环境</li></ol><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">conda create -n 环境名 python<span class="hljs-operator">=</span><span class="hljs-keyword">x</span>.<span class="hljs-keyword">x</span>.<span class="hljs-keyword">x</span><br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>激活虚拟环境</li></ol><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">conda <span class="hljs-built_in">activate</span> 环境名<br></code></pre></td></tr></table></figure><p>linux系统需要先激活base <figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">source <span class="hljs-built_in">activate</span><br></code></pre></td></tr></table></figure></p><ol start="4" type="1"><li>查看当前虚拟环境中有哪些库</li></ol><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">conda list</span><br></code></pre></td></tr></table></figure><ol start="5" type="1"><li>退出虚拟环境</li></ol><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">conda deactivate</span><br></code></pre></td></tr></table></figure><ol start="6" type="1"><li>删除虚拟环境</li></ol><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">conda <span class="hljs-built_in">remove</span> -n 环境名 –all<br></code></pre></td></tr></table></figure><ol start="7" type="1"><li>切换工作目录</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /d 路径<br></code></pre></td></tr></table></figure><h2 id="jupyter-notebook添加虚拟环境">Jupyter Notebook添加虚拟环境</h2><ol type="1"><li>安装ipykernel</li></ol><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">conda <span class="hljs-keyword">install</span> ipykernel<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>将虚拟环境添加到Jupyter Notebook</li></ol><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">python -m ipykernel <span class="hljs-keyword">install</span> –name 环境名<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python异常与文件</title>
    <link href="/posts/51459/"/>
    <url>/posts/51459/</url>
    
    <content type="html"><![CDATA[<h2 id="异常">异常</h2><h3 id="异常处理机制">异常处理机制</h3><p>Python程序通过了解释但是在执行时报错，这类错误即为异常。异常处理是通过try-except实现的。程序停止执行并提示错误信息即为抛出异常。异常捕获的完整语法如下：<figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs nim"><span class="hljs-keyword">try</span>:<br>    <span class="hljs-comment">#尝试执行的代码</span><br><span class="hljs-keyword">except</span> 错误类型<span class="hljs-number">1</span>:<br>    <span class="hljs-comment">#对应的代码处理</span><br><span class="hljs-keyword">except</span> (错误类型<span class="hljs-number">2</span>，错误类型<span class="hljs-number">3</span>):<br>    <span class="hljs-comment">#对应的代码处理</span><br><span class="hljs-keyword">except</span> <span class="hljs-type">Exception</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">result</span>:<br>    <span class="hljs-comment">#打印错误信息，result为捕获的异常对象</span><br>    print(<span class="hljs-built_in">result</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-comment">#没有异常才会执行的代码</span><br><span class="hljs-keyword">finally</span>:<br>    <span class="hljs-comment">#无论是否异常，都会执行的代码</span><br></code></pre></td></tr></table></figure></p><h3 id="异常传递">异常传递</h3><p>当函数执行出现异常，会将异常传递给函数的调用者。利用异常的传递性，在主程序捕获异常，不需要在每个函数中增加异常捕获的代码。Python中提供了Exception异常类。主动抛出异常的方法： 1. 创建一个Exception的对象 2.使用<strong>raise</strong>关键字抛出异常对象</p><p>示例如下： <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs vim">def input_password():<br>    <span class="hljs-keyword">pwd</span> = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入密码：&quot;</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(<span class="hljs-keyword">pwd</span>) &gt;= <span class="hljs-number">8</span>:<br>        <span class="hljs-keyword">print</span>(<span class="hljs-string">&quot;密码格式正确&quot;</span>)<br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">ex</span> = Exception(<span class="hljs-string">&quot;密码长度小于8位&quot;</span>)<br>        raise <span class="hljs-keyword">ex</span><br><br><span class="hljs-keyword">try</span>:<br>    input_password()<br>except Exception <span class="hljs-keyword">as</span> result:<br>    <span class="hljs-keyword">print</span>(<span class="hljs-string">&quot;程序异常：%s&quot;</span> % result)<br></code></pre></td></tr></table></figure></p><h2 id="文件">文件</h2><h3 id="模块">1.模块</h3><p><strong>一个Python文件就是一个模块</strong>。模块提供的工具有全局变量、函数、类等。</p><p>导入方式： （1）整个模块导入 <code>import 模块名 as 模块别名</code>as关键字指定别名（可以省略），模块别名应满足“大驼峰“命名规则，通过<code>模块名.</code>的方式使用工具。</p><p>（2）部分导入工具 <code>from 模块名 import 工具名</code>可以直接使用工具</p><p>注意： 1.如果两个模块存在同名函数，后导入模块的函数会覆盖先导入模块的函数。</p><ol start="2" type="1"><li>文件被导入时没有缩进的代码会被执行一遍。但是在实际开发中，模块下方可能会有一些测试代码，当被导入其他模块中执行时，这一部分代码也会被执行。可以通过__name__解决这一问题。__name__是Python内置的一个字符串，存储模块的名称，可以用来标记当前模块是否为顶层模块。如果一个模块是顶层模块，即当前模块直接运行（没有被其他模块调用），<strong>name</strong>==“<strong>main</strong>”；而当前模块被导入到其他模块调用时，__name__为当前模块名。</li></ol><h3 id="包">2.包</h3><p><strong>一个包是若干个模块的集合</strong>。实质是一个包含多个模块的特殊目录，目录下包含一个__init__.py文件，需要在该文件中指定对外界提供的模块列表。</p><p>包的命名规范为：全部小写字母，不推荐使用下划线。</p><p>包的结构为<strong>树状</strong>，可以进行分层组织，从而避免重名。例如一个包pkga的结构如下所示，它由两个子包pkgb和pkgc组成，两个子包都有同名模块module1。<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">pkga      <span class="hljs-comment">#顶层包a</span><br>|<span class="hljs-string">—— __init__.py</span><br><span class="hljs-string"></span>|<span class="hljs-string">—— pkgb        #子包b</span><br><span class="hljs-string"></span>|<span class="hljs-string">   </span>|<span class="hljs-string">—— __init__.py</span><br><span class="hljs-string"></span>|<span class="hljs-string">   </span>|<span class="hljs-string">—— module1.py</span><br><span class="hljs-string"></span>|<span class="hljs-string">   </span>|<span class="hljs-string">—— module2.py</span><br><span class="hljs-string"></span>|<br>|<span class="hljs-string">—— pkgc        #子包c</span><br><span class="hljs-string">    </span>|<span class="hljs-string">—— __init__.py</span><br><span class="hljs-string">    </span>|<span class="hljs-string">—— module1.py</span><br><span class="hljs-string">    </span>|<span class="hljs-string">—— module3.py</span><br></code></pre></td></tr></table></figure></p><p>如果要使用module2中的函数say()，则导入与使用方式如下：<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs stylus">#方式一：<br>import pkga<span class="hljs-selector-class">.pkgb</span><span class="hljs-selector-class">.module2</span><br>pkga<span class="hljs-selector-class">.pkgb</span><span class="hljs-selector-class">.module2</span><span class="hljs-selector-class">.say</span>()<br><br>#方式二（推荐）：<br>from pkga<span class="hljs-selector-class">.pkgb</span> import module2<br>module2<span class="hljs-selector-class">.say</span>()<br><br>#方式三：<br>from pkga<span class="hljs-selector-class">.pkgb</span><span class="hljs-selector-class">.module2</span> import say<br><span class="hljs-function"><span class="hljs-title">say</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python面向对象-继承与多态</title>
    <link href="/posts/27884/"/>
    <url>/posts/27884/</url>
    
    <content type="html"><![CDATA[<h2 id="继承">继承</h2><p>类的继承可以实现代码的重用和扩展，主要通过子类（派生类）继承父类（基类）的属性和方法。</p><p>在Python中，子类可以继承多个父类，此时子类具有所有父类的属性和方法，这种继承方式称为<strong>多继承</strong>。语法格式为：<code>class 子类名(父类名1, 父类名2, ...)：</code></p><p>注意： 1.如果父类之间存在同名的属性或方法，应尽量避免使用多继承。2.多个父类中，如果有同名的成员，那么默认以继承顺序（从左到右）为优先级。即：先继承的保留，后继承的被覆盖。3.子类不能在自己的方法内部直接访问父类的私有属性或方法；子类对象可以通过父类的公有方法间接访问私有属性或方法。4.<strong>object</strong>类是Python为所有对象提供的基类，有一些内置的属性和方法，可以使用dir函数查看。如果没有指定父类，则默认指定object类作为基类。</p><h2 id="重写">重写</h2><p>子类可以创建自己独有的属性和方法，也可以重写父类的方法，以实现子类的特定需求。</p><p>重写（<strong>Override</strong>）即在子类中定义父类中已有的方法。通过子类对象调用该方法时，将执行子类的方法，不会调用父类的方法；如果要使用被重写的父类方法，则需要按照<code>super().父类方法名</code>的格式进行调用。</p><p>示例如下： <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span>, name</span>):<br>        <span class="hljs-variable language_">self</span>.name = name<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):<br>        print(<span class="hljs-string">&quot;Animal:吃东西&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hunt</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):<br>        print(<span class="hljs-string">&quot;Animal:捕猎&quot;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-title class_">Animal</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):<br>        print(<span class="hljs-string">&quot;Dog%s:吃东西&quot;</span> % <span class="hljs-variable language_">self</span>.name)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hunt</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):<br>        <span class="hljs-comment"># 调用父类的方法 </span><br>        <span class="hljs-variable language_">super</span>().hunt()<br>        print(<span class="hljs-string">&quot;Dog%s:捕猎&quot;</span> % <span class="hljs-variable language_">self</span>.name)<br><br>dog=<span class="hljs-title class_">Dog</span>(<span class="hljs-string">&quot;旺财&quot;</span>)<br>dog.eat()<br>dog.hunt()<br></code></pre></td></tr></table></figure> 结果：Dog旺财:吃东西 Animal:捕猎Dog旺财:捕猎</p><p>注意：super函数可以使用父类的所有非私有方法（包括类方法、实例方法、静态方法）。</p><h2 id="多态">多态</h2><p>多态即不同的子类对象调用相同的父类方法时，会产生不同的执行结果，一般通过继承和重写实现。</p><p>Python中的多态与Java等强类型语言不同，即"<strong>鸭子类型</strong>"。在鸭子类型中，关注点在于对象是否具有调用的方法，而不是关注对象所属的类型。</p><p>示例如下： <figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">class</span> <span class="hljs-variable">Animal</span>:<br>    <span class="hljs-variable">def</span> <span class="hljs-function"><span class="hljs-title">eat</span>(<span class="hljs-variable">self</span>):</span><br><span class="hljs-function">        <span class="hljs-title">print</span>(<span class="hljs-string">&quot;Animal:吃东西&quot;</span>)</span><br><br><span class="hljs-variable">class</span> <span class="hljs-function"><span class="hljs-title">Dog</span>(<span class="hljs-variable">Animal</span>):</span><br><span class="hljs-function">    <span class="hljs-variable">def</span> <span class="hljs-title">eat</span>(<span class="hljs-variable">self</span>):</span><br><span class="hljs-function">        <span class="hljs-title">print</span>(<span class="hljs-string">&quot;Dog:吃东西&quot;</span>)</span><br><br><span class="hljs-variable">class</span> <span class="hljs-function"><span class="hljs-title">Bird</span>(<span class="hljs-variable">Animal</span>):</span><br><span class="hljs-function">    <span class="hljs-variable">def</span> <span class="hljs-title">eat</span>(<span class="hljs-variable">self</span>):</span><br><span class="hljs-function">        <span class="hljs-title">print</span>(<span class="hljs-string">&quot;Bird:吃东西&quot;</span>)</span><br><br><span class="hljs-variable">def</span> <span class="hljs-function"><span class="hljs-title">eat_food</span>(<span class="hljs-variable">animal</span>:<span class="hljs-variable">Animal</span>):</span><br><span class="hljs-function">    <span class="hljs-variable">animal.eat</span>()</span><br><br><span class="hljs-variable">dog</span> = <span class="hljs-function"><span class="hljs-title">Dog</span>()</span><br><span class="hljs-variable">bird</span> = <span class="hljs-function"><span class="hljs-title">Bird</span>()</span><br><span class="hljs-function"><span class="hljs-title">eat_food</span>(<span class="hljs-variable">dog</span>)</span><br><span class="hljs-function"><span class="hljs-title">eat_food</span>(<span class="hljs-variable">bird</span>)</span><br></code></pre></td></tr></table></figure> 结果：Dog:吃东西 Bird:吃东西</p><h2 id="单例设计模式">单例设计模式</h2><p>单例设计模式即使用类创建的对象在系统中只有唯一的一个实例。为了实现单例设计模式，需要重写__new__方法，在每次创建对象时只会得到第一次创建对象的引用。但是在这一过程中，__init__方法会被多次调用，因此需要使用一个标记来判断是否执行。</p><p>示例如下： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MusicPlayer</span>:<br><br>    <span class="hljs-comment"># 使用类属性保存创建第一个对象的内存空间</span><br>    instance = <span class="hljs-literal">None</span><br><br>    <span class="hljs-comment"># 使用类属性标记是否执行过初始化方法</span><br>    init_flag = <span class="hljs-literal">False</span><br><br>    <span class="hljs-comment"># 重写__new__方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, *args, **kwargs</span>):<br>        <span class="hljs-comment"># 判断类属性是否为空</span><br>        <span class="hljs-keyword">if</span> cls.instance <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-comment"># 调用父类方法为第一对象分配内存空间</span><br>            cls.instance = <span class="hljs-built_in">super</span>().__new__(cls)<br>        <span class="hljs-keyword">return</span> cls.instance<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> MusicPlayer.init_flag:<br>            MusicPlayer.init_flag = <span class="hljs-literal">True</span><br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;初始化播放&quot;</span>)<br><br>player1 = MusicPlayer()<br><span class="hljs-built_in">print</span>(player1)<br>player2 = MusicPlayer()<br><span class="hljs-built_in">print</span>(player2)<br></code></pre></td></tr></table></figure> 结果为：初始化播放 &lt;__ main __.MusicPlayer object at 0x000001D100C10160&gt; &lt; __ main__.MusicPlayer object at 0x000001D100C10160&gt;</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python面向对象-类的封装</title>
    <link href="/posts/18439/"/>
    <url>/posts/18439/</url>
    
    <content type="html"><![CDATA[<h2 id="类与对象">类与对象</h2><blockquote><p>在Python3中，一切皆为对象。</p></blockquote><p>类是一种抽象的数据结构，是对一类具有共同特征的事物的抽象，而对象是对类的实例化。<strong>对象的本质是一块内存空间</strong>。类的定义与对象的创建如下所示：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-comment"># 定义一个Hello类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Hello</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">say_hello</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):<br>        print(<span class="hljs-string">&quot;Hello world!&quot;</span>)<br>        <br><span class="hljs-comment"># 创建对象</span><br>hello_python = <span class="hljs-title class_">Hello</span>()<br>hello_python.say_hello()<br></code></pre></td></tr></table></figure><p>注意：1.self是对调用方法的对象自身的引用，<strong>实例方法的第一个参数必须为self</strong>2.调用实例方法时并不需要传递self参数3.变量与对象的关系：变量的本质是系统表中的一个元素，用来指向对象，是<strong>对象的引用</strong>，而不是对象本身。</p><p>内置函数dir可以查看对象内的所有属性和方法，传入参数为标识符/数据。<strong>None</strong>关键字表示空对象，是一个特殊的常量（与C++中的nullptr类似），常与is连用。</p><p><strong>is</strong>与<strong>isnot</strong>是身份运算符，用于比较两个对象的内存地址（id）是否一致。对于is而言，如果两个变量的引用对象为同一个，则返回true，反之返回false，isnot则相反。注意与==运算符的区别，==运算符比较的是两个对象的值是否相同，如下图所示：</p><figure><img src="/images/Python/类的封装-运算符区别.png"alt="is与==运算符的区别" /><figcaption aria-hidden="true">is与==运算符的区别</figcaption></figure><p>从这一例子也可以看出，可变数据类型与不可变类型在内存分配方式上的不同。<strong>如果两个不可变类型的变量的值相同，这两个变量指向同一块内存地址，本质上是一个对象（即引用计数）；如果两个可变类型的变量的值相同，这两个变量指向不同的地址，本质上是两个对象。</strong></p><p>对于不可变数据类型，对应变量的值发生变化时，原内存中的值不变，而是新开辟一块内存，让变量指向新的内存地址；对于可变类型，变量的值发生变化时没有开辟新的内存空间。</p><h2 id="类的成员">类的成员</h2><p>类的成员包括属性和方法两大类，其中属性可以分为实例属性和类属性，方法可以分为实例方法、类方法和静态方法等。下面将对这些属性和方法以及访问权限进行介绍。</p><h3 id="实例属性和实例方法">1. 实例属性和实例方法</h3><p>实例属性属于类的对象，需要在__init__方法中使用"<code>self.属性名 = 值</code>"进行定义，通过"<code>对象名.属性名</code>"调用。</p><p>实例方法即与类的对象相关的方法，要求第一个参数必须为self，即调用该方法的对象的引用，通过"<code>对象名.方法名</code>"调用。</p><p>示例如下： <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:<br>    <span class="hljs-comment"># 实例方法say_hello</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">say_hello</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):<br>        print(<span class="hljs-string">&quot;Hello world!&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span>, input_name</span>):<br>        <span class="hljs-comment"># 实例属性name</span><br>        <span class="hljs-variable language_">self</span>.name = input_name<br></code></pre></td></tr></table></figure></p><p>注意：每个对象具有独立的内存空间，<strong>只保存各自的实例属性，不保存实例方法</strong>。<strong>实例方法在内存中只有一份</strong>，调用时需要把对象的引用传入方法内部。</p><h3 id="类属性和类方法">2. 类属性和类方法</h3><p>在Python中，类是一种特殊的对象，即<strong>类对象</strong>。在程序运行时，一个类可以创建多个实例，但是<strong>类对象在内存中只有一个</strong>。</p><p>类属性是类对象本身的属性，属于整个类，而不是某一特定实例，所有实例之间共享一个副本。与实例属性不同，类属性直接在类中定义即可，不需要在__init__函数中进行定义。</p><p>类方法是类对象本身的方法，需要使用修饰器@<strong>classmethod</strong>来标识。定义类方法时，第一个参数必须是<strong>cls</strong>（调用时不需要传递该参数）。在类方法内部，可以通过<code>cls.类属性</code>或者<code>cls.类方法</code>分别直接访问类的属性或调用其他的类方法。在类方法中访问实例属性会导致错误。</p><p>通过<code>类名.类属性</code>或者<code>类名.类方法</code>的形式可以访问类属性或者调用类方法。也可以通过对象访问类属性或者调用类方法，即<code>对象名.类属性</code>或者<code>对象名.类方法</code>。</p><p>示例如下： <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Game:<br>    # 类属性 <br>    top_score = <span class="hljs-number">0</span><br><br>    def <span class="hljs-constructor">__init__(<span class="hljs-params">self</span>, <span class="hljs-params">name</span>)</span>:<br>        self.name = name<br><br>    # 类方法<br>    @classmethod<br>    def show<span class="hljs-constructor">_top_score(<span class="hljs-params">cls</span>)</span>:<br>        print(<span class="hljs-string">&quot;当前最高分为%d&quot;</span> % cls.top_score)<br><br>    def start<span class="hljs-constructor">_game(<span class="hljs-params">self</span>, <span class="hljs-params">score</span>)</span>:<br>        print(<span class="hljs-string">&quot;%s开始游戏&quot;</span> % self.name)<br>        <span class="hljs-keyword">if</span> <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Game</span>.</span></span>top_score &lt; score:<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Game</span>.</span></span>top_score = score<br><br>gamer1 = <span class="hljs-constructor">Game(<span class="hljs-string">&quot;小明&quot;</span>)</span><br>gamer1.start<span class="hljs-constructor">_game(150)</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Game</span>.</span></span>show<span class="hljs-constructor">_top_score()</span><br><br>gamer2 = <span class="hljs-constructor">Game(<span class="hljs-string">&quot;小华&quot;</span>)</span><br>gamer2.start<span class="hljs-constructor">_game(200)</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Game</span>.</span></span>show<span class="hljs-constructor">_top_score()</span><br></code></pre></td></tr></table></figure> 结果为：小明开始游戏 当前最高分为150小华开始游戏 当前最高分为200</p><h3 id="静态方法">3. 静态方法</h3><p>静态方法使用修饰器@<strong>staticmethod</strong>来标识，与类、类的对象无关，可以看作是类中定义的普通函数。通过<code>类名.静态方法名</code>调用，不需要创建对象。</p><p>示例如下： <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tool</span>:<br>    count = <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span>, name</span>):<br>        <span class="hljs-variable language_">self</span>.name = name<br>        <span class="hljs-title class_">Tool</span>.count += <span class="hljs-number">1</span><br><br>    <span class="hljs-comment"># 静态方法</span><br>    <span class="hljs-variable">@staticmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">use_tool</span>():<br>        print(<span class="hljs-title class_">Tool</span>.count)<br><br>tool1 = <span class="hljs-title class_">Tool</span>(<span class="hljs-string">&quot;剪刀&quot;</span>)<br>tool2 = <span class="hljs-title class_">Tool</span>(<span class="hljs-string">&quot;锤头&quot;</span>)<br>tool3 = <span class="hljs-title class_">Tool</span>(<span class="hljs-string">&quot;钳子&quot;</span>)<br><span class="hljs-title class_">Tool</span>.use_tool()<br></code></pre></td></tr></table></figure> 结果为：3</p><h3 id="访问权限">4. 访问权限</h3><p>与C++、Java等语言相比，Python对于类的成员没有严格的访问控制限制。为了避免命名冲突、保护类的内部数据和方法，可以将一些重要的数据或方法定义私有属性或私有方法。</p><p>在定义私有属性或私有方法时，需要在属性名或方法名前增加两个下划线，例如"__hello()"、"__name"等。</p><p>但Python目前的私有机制其实是伪私有，在类外部还是可以通过<code>对象名._类名__私有属性</code>或者<code>对象名._类名__私有方法</code>进行访问。</p><p>示例如下： <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Hello</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">say_hello</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):<br>        print(<span class="hljs-variable language_">self</span>.__name)<br><br>    <span class="hljs-keyword">def</span>  <span class="hljs-title function_">__init__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span>, name</span>):<br>        <span class="hljs-variable language_">self</span>.__name = name<br><br>hello_python = <span class="hljs-title class_">Hello</span>(<span class="hljs-string">&quot;xiaoli&quot;</span>)<br>hello_python.say_hello()<br>print(hello_python._Hello__name)<br></code></pre></td></tr></table></figure> 结果为：xiaoli xiaoli</p><h2 id="内置方法">内置方法</h2><ol type="1"><li><strong>init</strong></li></ol><p>__init__方法是类的<strong>构造方法</strong>，<strong>在创建对象时会自动调用</strong>，用于初始化对象的属性或者执行一些初始化操作。在__init__方法内部可以定义<strong>实例属性</strong>（即对象属性），并通过参数为这些属性赋初值，因此在创建对象时需要提供相应的参数。示例如下：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span>, cat_name</span>):<br>        <span class="hljs-variable language_">self</span>.name = cat_name<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):<br>        print(<span class="hljs-string">&quot;吃东西&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">drink</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):<br>        print(<span class="hljs-string">&quot;喝水&quot;</span>)<br><br>cat = <span class="hljs-title class_">Cat</span>(<span class="hljs-string">&quot;xiaomei&quot;</span>)<br>cat.eat()       <br>cat.drink()     <br>print(cat.name) <br></code></pre></td></tr></table></figure><p>结果为：吃东西 喝水 xiaomei</p><p>注意：实例属性只能在__init__方法中定义，不能在其他成员方法中定义。</p><ol start="2" type="1"><li><strong>del</strong></li></ol><p>__del__方法是一个特殊方法，用于在对象销毁前执行一些清理工作，比如关闭文件、释放资源等。在Python中，对象的销毁是通过垃圾回收机制实现的，__del__方法<strong>在对象被销毁时自动调用</strong>。</p><p>如果通过<strong>del</strong>关键字删除对象，则对象会被立刻销毁；如果没有，则在当前函数执行结束时销毁对象。示例如下：<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span>, cat_name</span>):<br>        <span class="hljs-variable language_">self</span>.name = cat_name<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__del__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):<br>        print(<span class="hljs-string">&quot;销毁对象%s&quot;</span> % <span class="hljs-variable language_">self</span>.name)<br><br>cat1 = <span class="hljs-title class_">Cat</span>(<span class="hljs-string">&quot;xiaomei&quot;</span>)<br>del cat1<br>print(<span class="hljs-string">&quot;hello&quot;</span>)<br></code></pre></td></tr></table></figure> 结果为：销毁对象xiaomei hello</p><ol start="3" type="1"><li><strong>str</strong></li></ol><p>__str__方法是Python中的一个特殊方法，用来定义一个对象的字符串表示形式，返回值为一个字符串。</p><p>当使用print函数输出对象变量时，默认会输出对象的类以及对象在内存中的地址。如果类中定义了__str__方法，则默认输出__str__方法的返回值。代码如下：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span>, cat_name</span>):<br>        <span class="hljs-variable language_">self</span>.name = cat_name<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.name<br><br>cat1 = <span class="hljs-title class_">Cat</span>(<span class="hljs-string">&quot;xiaomei&quot;</span>)<br>print(cat1)<br></code></pre></td></tr></table></figure><p>结果为：xiaomei</p><ol start="4" type="1"><li><strong>new</strong></li></ol><p>__new__是由<strong>object基类</strong>提供的内置<strong>静态方法</strong>，用于创建类实例。使用<code>类名()</code>创建对象时，Python解释器会调用__new__方法<strong>为对象分配空间，并返回对象的引用</strong>。Python解释器获得对象的引用后，将该引用作为第一个参数传递给__init__方法。</p><p>参考文章: 1. <ahref="https://zhuanlan.zhihu.com/p/331732504?ivk_sa=1024320u&amp;utm_id=0">彻底理解Python中对象、对象与变量引用的关系</a>2. <ahref="https://blog.csdn.net/cnds123/article/details/130898914">Python类的成员介绍</a></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>二分查找</title>
    <link href="/posts/42877/"/>
    <url>/posts/42877/</url>
    
    <content type="html"><![CDATA[<h2 id="二分查找概述">二分查找概述</h2><p>二分查找（BinarySearch，简称<strong>BS</strong>），又称<strong>折半查找</strong>，是一种效率很高的查找方法。</p><p>算法要求：1.线性表必须采用<strong>顺序存储</strong>结构，不能为链式结构2.元素已经排过序(<strong>有序</strong>)</p><p>算法原理：每次取搜索区间[low，high]中间位置mid的值进行判断，进而使搜索区间减半，即将原区间划分为[low,mid-1]和[mid+1,high]两个区间。重复这一过程，查找结束，获取目标值的索引或者未找到。</p><p>时间复杂度：每一次以中间元素作为根节点，将中间元素的左侧区间和右侧区间分别作为左子树和右子树，依次执行可以将整个区间转化为一棵<strong>二叉搜索树</strong>。该搜索树的高度为logn，因此时间复杂度为<strong>O（logn）</strong>。</p><p>对于二分查找的理解，Kmp算法的发明者Knuth曾经说过：思路很简单，细节是魔鬼。BS具有许多实现形式（循环、递归等），而这些形式在细节上有所不同，比如搜索区间（左开右闭、左闭右开、左闭右闭等）、循环条件、区间更新操作等。</p><h2 id="标准bs">标准BS</h2><p>搜索区间：[low,high]（<strong>左闭右闭</strong>）（下面以升序为例）思路：每次比较target与当前中间位置元素nums[mid]的大小。如果两者相等，则找到目标元素的索引；如果target比较大，则说明target在mid右侧；如果target比较小，则说明target在mid左侧。经过上述过程，<strong>low左侧的元素都比target小，high右侧的元素比target大</strong>，当low==high+1时，说明未找到元素，终止循环，见下图。</p><figure><img src="/images/BS/标准BS.png" alt="标准BS" /><figcaption aria-hidden="true">标准BS</figcaption></figure><p>代码： <figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs stan"><span class="hljs-type">int</span> binarySearch(<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt; nums, <span class="hljs-type">int</span> <span class="hljs-built_in">target</span>)&#123;<br>    <span class="hljs-type">int</span> low = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> high = nums.<span class="hljs-built_in">size</span>()-<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(low &lt;= high)&#123;<br>        <span class="hljs-type">int</span> mid = (low+high)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(nums[mid] == <span class="hljs-built_in">target</span>) <span class="hljs-keyword">return</span> mid;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &lt; <span class="hljs-built_in">target</span>) low = mid+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &gt; <span class="hljs-built_in">target</span>) high = mid-<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">//表示未找到</span><br>&#125;<br></code></pre></td></tr></table></figure></p><p>作用：查找某一个数 注意：</p><ol type="1"><li>由于mid本身已经判断过，无需进行下一步的搜索，因此区间更新操作为low=mid+1或者high=mid-1（而不是low=mid或者high=mid）。</li><li>循环判断条件为low&lt;=high，对应的终止条件为low==high+1，此时搜索区间为空。而如果改为low&lt;high，则终止条件为low==high，当前索引low没有被搜索。</li><li><strong>溢出问题</strong>：在low和high的值较大的情况下，计算mid时会产生整数溢出。因此可以将mid的计算形式改为<code>mid=low+(high-low)/2</code></li></ol><h2 id="边界问题">边界问题</h2><p>对于一些获取左右边界的问题，例如对于序列seq=[1，2，3，3，3，4，5]，target=3，如果想要获取第一个等于target的元素的下标，标准BS则无法解决。下面以查找左边界为例。</p><p>搜索区间：[low,high]（左闭右闭）思路：比较target与nums[mid]的大小，记第一个等于target的元素为elem。如果两者相等，则说明elem在mid左侧或者等于mid。如果target比较大，则说明elem在mid右侧；如果target比较小，则elem一定在mid左侧。<strong>low左侧的元素都比target小，high右侧的元素都大于等于target</strong>，当low==high+1时，终止循环，见下图。</p><figure><img src="/images/BS/左边界BS.png" alt="左边界BS" /><figcaption aria-hidden="true">左边界BS</figcaption></figure><p>代码： <figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs stan"><span class="hljs-type">int</span> binarySearch_lowerBound(<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt; nums, <span class="hljs-type">int</span> <span class="hljs-built_in">target</span>)&#123;<br>    <span class="hljs-type">int</span> low = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> high = nums.<span class="hljs-built_in">size</span>()-<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(low &lt;= high)&#123;<br>        <span class="hljs-type">int</span> mid = (low+high)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(nums[mid] == <span class="hljs-built_in">target</span>) high = mid-<span class="hljs-number">1</span>; <br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &lt; <span class="hljs-built_in">target</span>) low = mid+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &gt; <span class="hljs-built_in">target</span>) high = mid-<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(low == nums.<span class="hljs-built_in">size</span>() || nums[low] != <span class="hljs-built_in">target</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">//未找到</span><br>    <span class="hljs-keyword">return</span> low; <span class="hljs-comment">//找到左边界</span><br>&#125;<br></code></pre></td></tr></table></figure> 注意：1.与标准BS不同之处在于：当nums[mid]==target时，elem可能在mid左侧，因此high=mid-1，而不能返回索引。2.循环终止条件只有一个，即low==high+1，无论查找成功或者失败，只要满足这一条件时均会终止循环，因此需要判断是否查找成功。如果<strong>当前low对应的元素不等于target或者low等于数组长度</strong>（见下图），则查找失败；反之查找成功，此时low对应的元素即为elem。</p><figure><img src="/images/BS/左边界BS-low越界.png" alt="low越界" /><figcaption aria-hidden="true">low越界</figcaption></figure><p>附查找右边界的代码： <figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs stan"><span class="hljs-type">int</span> binarySearch_upperBound(<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt; nums, <span class="hljs-type">int</span> <span class="hljs-built_in">target</span>)&#123;<br>    <span class="hljs-type">int</span> low = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> high = nums.<span class="hljs-built_in">size</span>()-<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(low &lt;= high)&#123;<br>        <span class="hljs-type">int</span> mid = (low+high)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(nums[mid] == <span class="hljs-built_in">target</span>) low = mid+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &lt; <span class="hljs-built_in">target</span>) low = mid+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &gt; <span class="hljs-built_in">target</span>) high = mid-<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(high&lt;<span class="hljs-number">0</span> || nums[high] != <span class="hljs-built_in">target</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">//未找到</span><br>    <span class="hljs-keyword">return</span> high; <span class="hljs-comment">//找到右边界</span><br>&#125;<br></code></pre></td></tr></table></figure> <img src="/images/BS/右边界BS.png"alt="右边界BS" /></p><p><strong>参考文章</strong>： 1. <ahref="https://www.cnblogs.com/kyoner/p/11080078.html">详解二分查找算法</a>2. <ahref="https://blog.csdn.net/qjyws/article/details/126416671">算法刷题：二分查找及对应左边界和右边界的寻找整理</a>3. <a href="https://zhuanlan.zhihu.com/p/569929092">二分查找</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python函数进阶</title>
    <link href="/posts/53362/"/>
    <url>/posts/53362/</url>
    
    <content type="html"><![CDATA[<h2 id="函数的参数">函数的参数</h2><p>Python函数的参数传递方式为<strong>引用传递</strong>，即让形参变量指向实参变量所绑定的对象。引用即变量到对象的指针。</p><p>函数<strong>id</strong>()可以返回对象的id标识，每个对象由唯一的id标识。</p><p>注意：</p><ol type="1"><li>如果实参是可变类型，在函数内部通过形参调用<strong>方法</strong>改变数据的内容，会修改实参的值。</li><li>如果实参是可变类型，在函数体内部通过形参执行<strong>赋值语句</strong>，不会修改实参。使用赋值语句只会让形参指向一个新创建的对象，并不会对实参产生影响。</li></ol><figure><img src="/images/Python/函数进阶-通过形参执行赋值语句.png"alt="执行赋值语句" /><figcaption aria-hidden="true">执行赋值语句</figcaption></figure><ol start="3" type="1"><li><strong>如果实参是不可变类型，在函数体内修改不会影响实参的值。</strong></li></ol><p>变量的声明和赋值本质：把一个变量绑定到某个内存单元（即对象）。</p><h3 id="缺省参数">缺省参数</h3><p>具有默认值的参数为缺省参数（也称为可变参数）。注意：必须保证带有默认值的缺省参数在<strong>参数列表末尾</strong>，否则会报错。</p><figure><img src="/images/Python/函数进阶-缺省参数位置.png"alt="缺省参数位置" /><figcaption aria-hidden="true">缺省参数位置</figcaption></figure><h3 id="多值参数">多值参数</h3><p>当函数的参数数目不确定时可以使用多值参数。参数名前增加<strong>一个星号可以接收元组，两个星号可以接收字典</strong>。命名时通常采用以下方式：&gt;*args 存放元组参数 （args为arguments的缩写） &gt;**kwargs存放字典参数 （kw为keyword的缩写）</p><p>实例： <img src="/images/Python/函数进阶-多值参数.png"alt="多值参数" /></p><p><strong>拆包语法</strong>如果需要将一个元组变量直接传递给args，则在该变量前增加一个星号；如果需要将一个字典变量直接传递给kwargs，则在字典变量前增加两个星号。</p><figure><img src="/images/Python/函数进阶-拆包语法.png" alt="拆包语法" /><figcaption aria-hidden="true">拆包语法</figcaption></figure><p>注意：采用这种方式传递的字典变量的键必须为str类型。</p><h3 id="命名参数">命名参数</h3><p>Python在函数调用时默认按照位置顺序传递形参。而按照名称指定传入的参数称为命名参数（也称关键字参数）。采用这种方式<strong>传递的参数与顺序无关</strong>。如果存在多个缺省参数时，可以选择特定的参数进行传递。</p><figure><img src="/images/Python/函数进阶-命名参数.png" alt="命名参数" /><figcaption aria-hidden="true">命名参数</figcaption></figure><h2 id="函数的返回值">函数的返回值</h2><p>Python中函数的返回值采用<strong>引用传递</strong>方式。</p><figure><img src="/images/Python/函数进阶-返回值的引用传递.png"alt="返回值的引用传递" /><figcaption aria-hidden="true">返回值的引用传递</figcaption></figure><p>函数使用<strong>元组</strong>可以返回多个值，同时可以使用多个变量接收函数的多个返回值。</p><figure><img src="/images/Python/函数进阶-多个返回值.png" alt="多个返回值" /><figcaption aria-hidden="true">多个返回值</figcaption></figure><h2 id="变量的作用域和生存期">变量的作用域和生存期</h2><p><strong>全局变量</strong>：在函数和类之外声明的变量。<strong>局部变量</strong>：在函数体中声明的变量。</p><p>注意： 1.全局变量可以被不同的模块和函数访问，可能会导致程序错误，因此应尽量避免使用全局变量。2. 局部变量在函数执行时才会被创建。 3.如果在函数内部定义一个与全局变量同名的变量，该变量为局部变量。Python中不允许直接修改全局变量的值，如果需要修改则在函数内部使用<strong>global</strong>关键字。</p><figure><img src="/images/Python/函数进阶-修改全局变量.png"alt="使用global修改全局变量" /><figcaption aria-hidden="true">使用global修改全局变量</figcaption></figure><p>变量的生命周期（生存期）：变量从<strong>被创建到被系统回收</strong>的过程</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python基础-数据容器(3)</title>
    <link href="/posts/54928/"/>
    <url>/posts/54928/</url>
    
    <content type="html"><![CDATA[<h3 id="公共方法">公共方法</h3><p>在常用五种数据容器中，<strong>列表、元组、字符串</strong>为序列类型，集合和字典为无序类型。公共方法如下图所示：</p><figure><img src="/images/Python/数据容器(3)-公共方法.png" alt="公共方法" /><figcaption aria-hidden="true">公共方法</figcaption></figure><h3 id="运算符">运算符</h3><figure><img src="/images/Python/数据容器(3)-运算符.png" alt="运算符" /><figcaption aria-hidden="true">运算符</figcaption></figure><h3 id="迭代遍历">迭代遍历</h3><p>Python包括以下可迭代对象:<strong>序列类型、集合、字典、迭代器对象</strong>等。通用的遍历语句如下：<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">for</span> 变量 <span class="hljs-keyword">in</span> 可迭代对象集合：<br>循环体代码<br><span class="hljs-keyword">else</span>:<br>如果循环体内部使用<span class="hljs-keyword">break</span>退出循环，这一部分代码就不会被执行<br></code></pre></td></tr></table></figure>注：关键字<strong>Pass</strong>一般用于占位语句，可以保证程序的结构正确。程序运行时，pass不会执行任何操作。</p><h3 id="序列的切片">序列的切片</h3><p>切片操作可以截取序列的一部分，基本形式如下：</p><p><code>s[开始下标i: 结束下标j: 步长l]</code></p><p>截取部分的范围采用“<strong>左开右闭</strong>”原则。切片采用两种索引方式，分别为正索引和负索引。正索引：从序列首部到末尾依次为0、1、2...负索引：从序列末尾到首部依次为-1、-2、-3...</p><p>如果省略步长则默认步长为1。<strong>步长的正负决定截取的方向</strong>，如果步长为正数表示从左往右截取，反之为负数则表示从右往左截取。开始下标和结束下标均可以缺省，默认值为<strong>序列在当前截取方向上的起点和终点</strong>。例如对于列表a= [0,1,2]，如果步长为负，则开始下标的缺省值为2，结束下标为0。</p><p>以列表为例： <img src="/images/Python/数据容器(3)-切片.png"alt="序列的切片" /></p><p>注意:在切片中，<strong>如果索引超出有效范围不会报错</strong>，而是会进行<strong>截断</strong>，即超出部分全部视为空值，最终获取时忽略这一部分空值。</p><p>应用:无需遍历即可获取序列的<strong>逆序</strong></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python基础-数据容器(2)</title>
    <link href="/posts/18065/"/>
    <url>/posts/18065/</url>
    
    <content type="html"><![CDATA[<h2 id="字符串-str">字符串 str</h2><h3 id="常用方法总结">1.常用方法总结</h3><p>其中s1、s2均代表字符串</p><ol type="1"><li><p>统计与查找 <figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-built_in">s1</span>.count(<span class="hljs-built_in">s2</span>) <span class="hljs-comment"># 统计子字符串s2在s1中出现的次数</span><br><br><span class="hljs-built_in">s1</span>.index(<span class="hljs-built_in">s2</span>) <span class="hljs-comment"># 获取子字符串s2在s1中的起始下标</span><br><span class="hljs-built_in">s1</span>.find(<span class="hljs-built_in">s2</span>) <span class="hljs-comment"># 查找子串s2并返回起始下标</span><br><span class="hljs-comment"># index与find区别在于：如果子串不存在，find方法返回-1，而index方法会报错</span><br></code></pre></td></tr></table></figure></p></li><li><p>判断 <figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta"># 返回值均为布尔型</span><br>s.isdecimal() <span class="hljs-meta"># 判断是否为数字，不能判断小数</span><br>s.isdigit() <span class="hljs-meta"># 判断是否为数字，支持判断单字节数字，不能判断小数</span><br>s.islower() <span class="hljs-meta"># 判断字母是否全为小写</span><br>s.isupper() <span class="hljs-meta"># 判断字母是否全为大写</span><br>s.isspace() <span class="hljs-meta"># 判断是否为空格</span><br></code></pre></td></tr></table></figure></p></li><li><p>替换 <figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-built_in">s2</span> = <span class="hljs-built_in">s1</span>.replace(<span class="hljs-keyword">sub1,sub2) </span><span class="hljs-comment"># 将s1中的所有子串sub1替换为sub2，返回一个新字符串</span><br><span class="hljs-built_in">s2</span> = <span class="hljs-built_in">s1</span>.upper()  <span class="hljs-comment"># 将s1所有字母转为大写，返回一个字符串</span><br><span class="hljs-built_in">s2</span> = <span class="hljs-built_in">s1</span>.lower()  <span class="hljs-comment"># 将s1所有字母转为小写，返回一个字符串</span><br></code></pre></td></tr></table></figure></p></li><li><p>分割与拼接 <figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">s_list</span> = s.split()   <span class="hljs-comment"># 分割字符串，返回一个列表。</span><br><span class="hljs-comment"># 如果参数为空，则默认以空白字符为分隔符进行拆分；</span><br><span class="hljs-comment"># 如果不为空，则按照该字符进行分割，结果中不包括该字符。</span><br><br><span class="hljs-attr">s2</span> = s1.join(seq) <span class="hljs-comment"># 拼接字符串，以s1作为连接符，seq为字符或字符串序列。</span><br><span class="hljs-attr">s2</span> = s1 * num    <span class="hljs-comment"># 将s1拼接num次</span><br></code></pre></td></tr></table></figure></p></li></ol><p>实例： <img src="/images/Python/数据容器(2)-split.png"alt="字符串分割" /> <img src="/images/Python/数据容器(2)-join.png"alt="字符串拼接" /></p><ol start="5" type="1"><li>文本对齐 <figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># 使用指定字符（默认为空格）将内容填充至长度length，返回一个新字符串</span><br><span class="hljs-attr">s2</span> = s1.center(length)  <span class="hljs-comment"># 居中对齐</span><br><span class="hljs-attr">s2</span> = s1.ljust(length)   <span class="hljs-comment"># 左对齐</span><br><span class="hljs-attr">s2</span> = s1.rjust(length)   <span class="hljs-comment"># 右对齐</span><br></code></pre></td></tr></table></figure></li></ol><p>实例： <img src="/images/Python/数据容器(2)-just.png"alt="文本对齐" /></p><ol start="6" type="1"><li>去除空白字符 <figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">s2</span> = s1.strip()   <span class="hljs-comment"># 去除左右两侧的空白字符（\t\n\r等）</span><br><span class="hljs-attr">s2</span> = s1.lstrip()  <span class="hljs-comment"># 去除左侧的空白字符</span><br><span class="hljs-attr">s2</span> = s1.rstrip()  <span class="hljs-comment"># 去除右侧的空白字符</span><br></code></pre></td></tr></table></figure></li></ol><p>实例： <img src="/images/Python/数据容器(2)-strip.png"alt="去除空白字符" /></p><h3 id="字符串的格式化">2.字符串的格式化</h3><p>字符串的格式化是一种将数据转化为特定格式的字符串的方法。在Python中主要有以下几种实现形式：</p><ol type="1"><li>%形式</li></ol><p><code>格式化字符串 % (值1,值2,...)</code></p><p>在格式化字符串内部，%操作符起占位作用，%之后的部分是需要格式化的内容，可以使用变量对这些内容进行替换。常见的几种格式化字符如下：<img src="/images/Python/数据容器(2)-format_char.png"alt="格式化字符" /></p><p>实例： <img src="/images/Python/数据容器(2)-百分号形式.png"alt="%形式" /></p><ol start="2" type="1"><li>format形式</li></ol><p><code>格式化字符串.format(值1,值2,...)</code></p><p>在格式化字符串内部，{}为占位符，{}内部为需要格式化的内容。format函数中常见的格式化字符与%形式的基本一致，例如s代表字符串，d代表十进制整数，f代表浮点数。</p><p>注意：{}内部第一部分为索引或键，第二部分为格式符号（包括格式化字符等），两部分之间用冒号隔开。如果{}内部不写索引，默认从0开始递增排列。</p><p>实例： <img src="/images/Python/数据容器(2)-format_format.png"alt="format形式" /></p><p>与%形式相比，format函数能够可以实现文本对齐、百分制等更为复杂的功能。</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python基础-数据容器(1)</title>
    <link href="/posts/46737/"/>
    <url>/posts/46737/</url>
    
    <content type="html"><![CDATA[<h2 id="列表-list">1.列表 list</h2><p>列表（即数组）索引值从0开始，一般情况下默认列表中的所有数据的类型一致。</p><p>常用方法如下： <img src="/images/Python/数据容器(1)-list.png"alt="列表常用方法总结" /></p><p>注意： 1. clear与del的区别clear会清除列表中所有元素，但内存并未释放，仍然可以通过变量名访问；<strong>del关键字会将变量从内存中删除</strong>，此时不能继续使用变量名，否则会报错。如果仅删除某一个索引对应的元素，则后续元素均向前移动一位，索引值均减1。区别见下图：</p><figure><img src="/images/Python/数据容器(1)-del.png" alt="del删除列表" /><figcaption aria-hidden="true">del删除列表</figcaption></figure><ol start="2" type="1"><li>append与extend的区别extend用于合并列表，将需要插入的列表的元素加入原列表，参数为<strong>可迭代对象</strong>；append直接将整个对象当作一个元素加入原列表末尾，参数为任意对象。其区别见下图：</li></ol><figure><img src="/images/Python/数据容器(1)-append.png" alt="append与extend" /><figcaption aria-hidden="true">append与extend</figcaption></figure><h2 id="元组-tuple">2.元组 tuple</h2><p>元组是由多个元素组成的序列，<strong>元组的元素不能被修改</strong></p><p><strong>元组只包含一个元素时需要在元素后面添加逗号</strong></p><p>常用方法：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-meta"># t代表元组</span><br><br>t.<span class="hljs-keyword">count</span>(k) <span class="hljs-meta"># 统计数据k出现的次数</span><br><br>t.<span class="hljs-keyword">index</span>(k) <span class="hljs-meta"># 查找数据k，返回数据k第一次匹配时的索引位置，如果对象不在元组中会产生异常</span><br><br>len(t) <span class="hljs-meta"># 统计元组的长度</span><br></code></pre></td></tr></table></figure><p>应用：（1）函数的参数和返回值（2）格式化字符串（3）将列表转化为元组，保证数据安全</p><p>元组和列表的转换 元组-&gt;列表：列表=list（元组）列表-&gt;元组：元组=tuple（列表）</p><p>面试题：交换两个数字a=6,b=100,不能使用其他变量 解法一：a=a+b b=a-ba=a-b 解法二：使用元组 a,b=(b,a)</p><h2 id="集合">3.集合</h2><p>Python中的集合与数学上的集合一致。集合是<strong>无序</strong>对象的聚集，并且集合中的元素<strong>不重复</strong>。存储的元素为字符串、数值类型或者元组等<strong>不可变类型</strong>。集合的内部实现基于<strong>哈希表</strong>。集合之间可以进行并集、交集、差集等运算。</p><p>集合分为可变集合set和不可变集合frozenset。下面主要介绍可变集合的常用方法(其中s、s1、s2均代表集合名)：</p><ol type="1"><li><p>添加 <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">s.<span class="hljs-keyword">add</span>(elem)  <span class="hljs-meta"># 向集合添加一个元素elem，如果该元素已存在则不产生效果</span><br>s.update(iter)  <span class="hljs-meta"># 将可迭代对象iter的元素添加到集合中   </span><br></code></pre></td></tr></table></figure></p></li><li><p>删除 <figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs maxima">s.<span class="hljs-built_in">remove</span>(<span class="hljs-built_in">elem</span>) # 删除指定元素<span class="hljs-built_in">elem</span>，如果不存在会报错<br>s.discard(<span class="hljs-built_in">elem</span>) # 删除指定元素<span class="hljs-built_in">elem</span>，如果不存在则忽略<br>s.clear()   # 清空集合<br></code></pre></td></tr></table></figure></p></li><li><p>集合运算 <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">s1</span> &amp; s2 <span class="hljs-comment"># 交集</span><br>s1 | s2 <span class="hljs-comment"># 并集</span><br>s1 - s2 <span class="hljs-comment"># 差集</span><br></code></pre></td></tr></table></figure>注意：如果要创建一个空集合，则必须用set函数创建，不能使用{}创建（否则会创建一个空字典）</p></li></ol><h2 id="字典-dict">4.字典 dict</h2><p>字典是<strong>存储无序</strong>的对象集合（列表存储的是有序对象），是键和值的<strong>哈希映射</strong>关系。它的实现同样基于<strong>哈希表</strong>。</p><p>特点：（1）使用键值对存储数据，键值对之间使用逗号分隔，键和值之间使用冒号分隔（2）<strong>键必须唯一</strong>（3）键必须是<strong>不可变类型</strong>，值可以取任意数据类型</p><p>字典的常用方法如下(其中d代表字典名,key代表键，value代表值)：</p><ol type="1"><li><p>添加 <figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs q">d[<span class="hljs-built_in">key</span>]=<span class="hljs-built_in">value</span>   # 如果<span class="hljs-built_in">key</span>存在，修改已存在的键值对；如果<span class="hljs-built_in">key</span>不存在，新增键值对<br><br>d1.<span class="hljs-keyword">update</span>(d2) <br># 将字典d2合并到字典d1中。如果字典d1和字典d2存在相同的键，则将对原键值对进行覆盖<br></code></pre></td></tr></table></figure></p></li><li><p>查看 <figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">keys</span> = d.keys()      <span class="hljs-comment"># 获取所有键key</span><br><span class="hljs-attr">values</span> = d.values()  <span class="hljs-comment"># 获取所有值value</span><br><span class="hljs-attr">items</span> = d.items()    <span class="hljs-comment"># 获取字典中的每一个元素</span><br></code></pre></td></tr></table></figure>这三种方法的返回值均为<strong>可迭代的视图对象</strong>，它们并不具备列表的功能，即无法通过索引获取元素、无法修改、无法使用内置方法等，仅支持迭代遍历。可以通过list函数将这些对象转化为列表进行操作。</p></li></ol><p>实例： <img src="/images/Python/数据容器(1)-keys.png"alt="视图对象" /></p><ol start="3" type="1"><li><p>删除 <figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">del</span> d[<span class="hljs-built_in">key</span>]  # 删除键为<span class="hljs-built_in">key</span>对应的键值对<br><span class="hljs-built_in">del</span> d       # 删除整个字典，释放内存空间<br>d.<span class="hljs-built_in">pop</span>(<span class="hljs-built_in">key</span>)  # 如果键<span class="hljs-built_in">key</span>存在，返回并删除其值；如果指定的<span class="hljs-built_in">key</span>不存在，则会报错<br>d.clear()   # 清除字典中的元素<br></code></pre></td></tr></table></figure></p></li><li><p>迭代遍历 <figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> d:      <span class="hljs-meta"># k为每次遍历获得的键值对的key</span><br>    <span class="hljs-keyword">print</span>(k,d[k]) <br></code></pre></td></tr></table></figure></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python基础-基本语法</title>
    <link href="/posts/61427/"/>
    <url>/posts/61427/</url>
    
    <content type="html"><![CDATA[<h2 id="基本语法">基本语法</h2><h3 id="数据类型与运算符">1.数据类型与运算符</h3><blockquote><p>Python中变量不需要显式声明数据类型。程序运行时，Python解释器会根据赋值语句等号右侧的数据自动推导出变量保存数据的类型。</p></blockquote><p>Python内置数据类型可以分为数值数据类型和非数值数据类型。其中内置数值数据类型有4种：int、float、bool、complex（复数类型），非数值数据类型有str、tuple（元组）、list（列表）、dict（字典）等。</p><p>Python数据类型可分为可变类型和不可变类型两种。<strong>不可变类型</strong>：数据不允许被修改。包括数值数据类型（4种）、str、tuple等。<strong>可变类型</strong>：数据可以被修改。包括list、可变集合set、dict等。</p><p>Python中的运算符与C++基本一致，需要注意以下几个： 1.与C++不同，Python中逻辑运算符为and、or、not 2. <strong>表示乘方运算 3./表示浮点数除法，而//表示</strong>除法取整**</p><h3 id="标识符">2.标识符</h3><p>Python标识符的命名规则： 1. 由<strong>字母、下划线和数字</strong>组成2. 不能由数字开头 3. 不能与关键字重名</p><p>注：Python中的标识符是区分大小写的</p><p><strong>关键字</strong>即Python内部已经使用的标识符</p><p>Python命名规范：（1）变量、函数、模块、包：<strong>单词的首字母采用小写字母，单词之间用下划线连接</strong>，例如：first_name（2）类名：大驼峰，例如：MyHome（3）常量名：所有字符全部大写，例如：LEFT</p><p>补充：在其他语言中，标识符的命名常采用<em>驼峰法</em>&gt;大驼峰（又称<strong>Pascal命名法</strong>）：组成标识符的每个单词首字符都采用大写字母&gt;小驼峰：第一个单词以小写字母开始，后续单词的首字母大写</p><h3 id="程序结构">3.程序结构</h3><ol type="1"><li>顺序结构</li><li>分支结构：if、else、elif（等价于C语言的else if）等</li><li>循环结构：for、while、break、continue等</li></ol><h3 id="变量">4.变量</h3><p>程序中的数据保存在内存之中，Python并不像汇编语言和机器语言那样直接通过内存地址访问数据，而是通过赋值语局将变量<strong>绑定</strong>到相应的内存单元，之后通过变量来访问数据。</p><blockquote><p>如果<em>环境</em>将名字x映射到存储单元s，则称x被<em>绑定</em>到s。环境表示将名字映射到存储单元的函数。——陈意云，张昱《编译原理（第三版）》</p></blockquote><p><strong>Python变量被访问之前必须进行初始化，即赋值。</strong></p><h3 id="函数和模块">5.函数和模块</h3><p>使用<strong>import</strong>关键字可以导入模块（包/Python源文件）。生成随机数的代码如下：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-comment"># 随机生成一个[1，100]的整数</span><br>import <span class="hljs-built_in">random</span><br><span class="hljs-built_in">num</span> = <span class="hljs-built_in">random</span>.randint(<span class="hljs-number">1</span>,<span class="hljs-number">100</span>)                     <br></code></pre></td></tr></table></figure><p>补充：在导入模块时，Python解释器会在与模块文件同一目录的__pycache__子目录下生成.pvc文件。pyc文件是由Python解释器<strong>编译过的字节码文件</strong>。字节码是一种低级的、与平台无关的代码，可以被Python虚拟机直接执行，提高程序的执行速度。</p><p>Python解释源程序分为两个步骤：（1）处理源代码，编译生成一个二进制字节码（2）对字节码进行处理，生成CPU能够识别的机器码</p><p>函数定义使用<strong>def</strong>关键字，其中参数不包含类型。在使用其他文件或模块定义的函数时，需要先使用import关键字导入该文件。</p><h3 id="输入和输出函数">6.输入和输出函数</h3><p><strong>input</strong>函数能够接收从键盘输入的数据，<strong>返回字符串类型</strong>。其中括号内的信息为提示信息，并不包含在返回值中。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">name</span> <span class="hljs-operator">=</span> input(<span class="hljs-string">&quot;请输入姓名：&quot;</span>)<br></code></pre></td></tr></table></figure><p><strong>print</strong>函数能够打印输出文本，并且可以实现格式化输出。print函数由参数end指定换行符，默认输出内容后在末尾自动换行，即end=''。</p><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs hsp"><span class="hljs-keyword">print</span>(<span class="hljs-string">&quot;我的名字是%s&quot;</span> % name)    <span class="hljs-meta">#输出格式化字符串</span><br><span class="hljs-keyword">print</span>(<span class="hljs-string">&quot;hello world&quot;</span>, <span class="hljs-keyword">end</span> = <span class="hljs-string">&quot;&quot;</span>)  <span class="hljs-meta"># 不换行</span><br></code></pre></td></tr></table></figure><p>补充： 常用的几种转义字符如下所示：</p><figure><img src="/images/Python/基本语法-转义字符.png" alt="转义字符" /><figcaption aria-hidden="true">转义字符</figcaption></figure><p>注：够使文本在垂直方向上保持对齐</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python基础-预备知识</title>
    <link href="/posts/32360/"/>
    <url>/posts/32360/</url>
    
    <content type="html"><![CDATA[<h2 id="python简介">Python简介</h2><p>Python是由<strong>吉多.范罗苏姆</strong>(Guido vanRossum)创造的一门独特的程序设计语言。Python是一门<strong>完全面向对象</strong>的语言,它遵循优雅、明确、简单的设计哲学。</p><p>Python语言具有简单易学、开源、面向对象等优点，但与C/C++相比，它的运行速度较慢，同时这门语言对格式的要求极为严格。</p><h2 id="预备知识">预备知识</h2><h3 id="编译与解释">编译与解释</h3><p>计算机无法直接执行使用高级语言编写的源程序，只能够识别执行低级的机器指令，因此需要一种翻译程序，将源程序转化为CPU能够执行的机器指令。翻译方式可以分为解释和编译两种，具体运行过程见下图。</p><figure><img src="/images/Python/预备知识-compile.png" alt="编译与解释" /><figcaption aria-hidden="true">编译与解释</figcaption></figure><p><strong>编译</strong>是先将整个程序源代码翻译为等价的机器语言或者汇编语言格式的目标程序，之后再由CPU执行，例如C、C++等。<strong>解释</strong>是逐行翻译源程序，每翻译一句，CPU就执行一句，不产生目标代码，例如R、Python等。</p><p><strong>编译型语言的执行速度快，解释型语言跨平台性能好</strong>，而Java的跨平台是通过虚拟机实现的。</p><h3 id="调试">调试</h3><p>调试方法：在某一行设置一个断点，当程序执行到断点时暂时停止继续执行，之后通过单步调试继续向下执行。</p><p>程序断点原理：断点（breakpoint）的本质是一个<strong>中断信号</strong>，CPU执行至断点时产生中断，由调试器将程序挂起，此时程序并没有终止或者结束。</p><p>常用的调试器提供了多种单步调试方式： 1. stepinto：进入子函数内部并继续单步执行 2. stepover：不会进入子函数内部单步执行，而是把整个子函数当作一步执行 3. stepout：将子函数中剩余部分执行完，返回上一级函数，与step into配合使用</p><h3 id="python程序排错">Python程序排错</h3><ol type="1"><li>每行代码完成一个动作，因此不能把多条语句写在同一行。</li><li>缩进错误。（由于对格式的严格要求，Python语言也被称为“<strong>游标卡尺语言</strong>”）</li></ol><h3 id="python执行方式">Python执行方式</h3><ol type="1"><li>解释器</li><li>交互式shell。默认shell适用于学习/验证Python的语法或者局部代码</li><li>IPython交互式shell</li><li>IDE。例如Pycharm、Anaconda等</li></ol>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>First Article</title>
    <link href="/posts/43398/"/>
    <url>/posts/43398/</url>
    
    <content type="html"><![CDATA[<p>Welcome to my blog！This is my first article.</p><p>我其实很早就想搭建一个个人博客，但是由于各种事情一直没能实现。考完研之后这一想法再次涌上心头，于是花了一天时间终于把各种软件的安装和配置给弄完了。下面就将用到一些教程和注意事项贴出。</p><h3 id="创建博客">创建博客</h3><p>我主要是按照这三篇教程一步一步操作的，从Git、nodejs、hexo的安装到将个人博客部署到github。这几篇教程对新手十分友好。</p><p><ahref="https://cloud.tencent.com/developer/article/1373210">一文教会你如何搭建个人博客</a><ahref="https://blog.csdn.net/sparkstark/article/details/124967315">Hexo个人博客安装及配置</a><ahref="https://blog.csdn.net/guixinchn/article/details/107787660">Hexo博客部署到远程仓库（Conding、Gitee、Github）</a></p><p>第一篇文章中最核心的部分是<strong>将博客部署到远端</strong>（即github），但是按照该文章的步骤会报错。原因是没有配置用户的电子邮件地址和个人名，为此在部署前需要在bash中输入以下命令：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">$ git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.email</span> <span class="hljs-string">&quot;2210749324@qq.com&quot;</span><br>$ git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.name</span> <span class="hljs-string">&quot;Wangfuxun&quot;</span><br></code></pre></td></tr></table></figure><p>--global表示修改用户主目录下的配置信息，如果不含这一项，修改的仅为当前文件夹blog下的_config文件中的配置信息。</p><h3 id="注意">注意</h3><ol type="1"><li><p>在下载Git时，建议下载旧版本，比如2.38.0/2.38.1，因为最新版2.39.0有bug，可能无法将博客部署到github（本人已踩过坑）。</p></li><li><p>Git官网下载非常慢，建议直接在镜像网站（比如淘宝）下载。</p></li><li><p>在部署时，遇到了一些问题，其解决方法如下，亲测好用。</p></li></ol><p><ahref="https://blog.csdn.net/lvoelife/article/details/127370301">一文解决OpenSSLSSL_read: Connection was reset, errno 10054问题</a> <ahref="https://blog.csdn.net/m0_66695483/article/details/125036055">解决Failedto connect to github.com port 443: Timed out</a></p><ol start="4" type="1"><li>为了使文章有唯一的编号，使用了abbrlink插件生成文章链接。需要注意在hexo配置文件_config中修改permalink时需要注意加上末尾的/，如果缺失，文章链接会变为下载链接。</li></ol><p><ahref="https://blog.csdn.net/m0_51755720/article/details/127996199">Hexo使用Abbrlink插件生成文章固定编号链接</a></p><h3 id="其他">其他</h3><p>在写博客时需要使用到markdown语法，非常简单，并且支持HTML标签。<ahref="https://www.jianshu.com/p/191d1e21f7ed">Markdown基本语法</a></p><p>为了导入本地图片，需要按照这篇文章的内容进行操作，否则图片无法加载（已踩坑）。<ahref="https://blog.csdn.net/kantaiyang/article/details/129159055">hexo无法显示本地图片的问题</a></p><p>加载图片格式如下,本地路径使用绝对路径或相对路径均可，例如：E:/MyBlog/blog/source/images/test.png或者/images/test.png。</p><p><code>![图片题注](图片存放路径)</code></p><p>在Hexo官方文档中对写作/生成静态文档/配置等内容都有详细的介绍，有需要的话可以查看</p><p><a href="https://hexo.io/docs/">Documentation</a></p><p>以后我会不定期地在博客中更新自己的各种学习笔记。最后作为小白，我会努力向各位优秀的大佬学习，争取成为一个好的程序员，欢迎各位大佬指正不足。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
