<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>排序算法-非比较排序</title>
    <link href="/posts/25823/"/>
    <url>/posts/25823/</url>
    
    <content type="html"><![CDATA[<h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>计数排序是一种非比较排序算法，采用了<strong>哈希</strong>思想。</p><p>算法思路：</p><ol><li>找出待排序序列的最大值和最小值，确定序列元素的范围。</li><li>创建一个计数数组用来统计序列中每个元素的出现次数。</li><li>采用<strong>前缀和</strong>思想对计数数组进行修改，获得每个元素最终位置的右边界。</li><li><strong>从右向左</strong>遍历待排序序列，根据前缀和数组确定当前元素的最终位置。</li></ol><p>代码：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs glsl">public static <span class="hljs-type">void</span> countSort(<span class="hljs-type">int</span>[] arr)&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-built_in">min</span> = arr[<span class="hljs-number">0</span>], <span class="hljs-built_in">max</span> = arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">length</span>; i++)&#123;<br>        <span class="hljs-keyword">if</span>(arr[i] &lt; <span class="hljs-built_in">min</span>)&#123;<br>            <span class="hljs-built_in">min</span> = arr[i];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(arr[i] &gt; <span class="hljs-built_in">max</span>)&#123;<br>            <span class="hljs-built_in">max</span> = arr[i];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">int</span>[] cnt = new <span class="hljs-type">int</span> [<span class="hljs-built_in">max</span> - <span class="hljs-built_in">min</span> + <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">//统计每个元素出现的次数</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">length</span>; i++)&#123;<br>        cnt[arr[i] - <span class="hljs-built_in">min</span>] ++;<br>    &#125;<br><br>    <span class="hljs-comment">//对计数数组进行修改，获得每个元素的右边界</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; cnt.<span class="hljs-built_in">length</span>; i++)&#123;<br>        cnt[i] += cnt[i<span class="hljs-number">-1</span>];<br>    &#125;<br>    <br>    <span class="hljs-type">int</span>[] newArr = new <span class="hljs-type">int</span>[arr.<span class="hljs-built_in">length</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = arr.<span class="hljs-built_in">length</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>        newArr[--cnt[arr[i] - <span class="hljs-built_in">min</span>]] = arr[i];<br>    &#125;<br><br>    System.arraycopy(newArr, <span class="hljs-number">0</span>, arr, <span class="hljs-number">0</span>, arr.<span class="hljs-built_in">length</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度为O(n+k)，空间复杂度为O(n+k)，其中<code>k = max - min + 1</code>，是一种<strong>稳定</strong>排序算法。</p><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>桶排序也称为箱排序，是一种非比较排序算法。</p><p>算法思路：将待排序序列的数据范围划分为若干个子区间，每一个子区间相当于一个桶。将待排序元素分散到这些桶中，这一过程称为<strong>分配</strong>。然后，对每个桶分别进行排序，可以使用其他排序算法或者递归使用桶排序。最后按照桶的顺序，对每个桶中的元素进行合并，这一过程称为<strong>收集</strong>，最终获得有序序列。如图所示。</p><p><img src="/../images/sort/%E6%A1%B6%E6%8E%92%E5%BA%8F.png" alt="桶排序"></p><p>桶排序适用于<strong>待排序序列中元素分布比较均匀</strong>的情况。</p><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>基数排序是一种<strong>分配式排序</strong>，使用了<strong>桶排序</strong>的思想。它可以分为最高位优先（MSD）和最低位优先（LSD）两种。最高位优先就是先按照每一个元素最高位进行排序，然后依次对低位进行排序；最低位优先则是先按照每一个元素最低位进行排序，然后依次对高位进行排序。通常使用最低位优先。</p><p>算法思路：从最低位（即个位）开始，按照十位、百位……最高位的顺序，依次对所有位进行排序，排序过程包括以下两步：<br><strong>1.分配</strong>：按照当前位将数据分到相应的桶中，不考虑其他位。<br><strong>2.收集</strong>：将所有桶中的数据进行合并，合并过程按照<strong>先进先出</strong>的原则进行。</p><p>代码：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">radixSort</span>(<span class="hljs-type">int</span>[] arr)&#123;<br>    <span class="hljs-comment">//找出数组中的最大值</span><br>    <span class="hljs-type">int</span> <span class="hljs-built_in">max</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++)&#123;<br>        <span class="hljs-keyword">if</span>(arr[i] &gt; <span class="hljs-built_in">max</span>)&#123;<br>            <span class="hljs-built_in">max</span> = arr[i];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//获取最大位数</span><br>    <span class="hljs-type">int</span> digit = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">max</span> !=<span class="hljs-number">0</span> )&#123;<br>        digit++;<br>        <span class="hljs-built_in">max</span> /= <span class="hljs-number">10</span>;<br>    &#125;<br><br>    List&lt;LinkedList&lt;Integer&gt;&gt; buckets = <span class="hljs-keyword">new </span><span class="hljs-class title_">ArrayList</span>&lt;&gt;(<span class="hljs-number">10</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)&#123;<br>        buckets.<span class="hljs-property">add</span>(<span class="hljs-keyword">new </span><span class="hljs-class title_">LinkedList</span>&lt;&gt;());<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-built_in">exp</span> = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(digit != <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">//分配</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++)&#123;<br>            buckets.<span class="hljs-property">get</span>((arr[i] / <span class="hljs-built_in">exp</span>)%<span class="hljs-number">10</span>).<span class="hljs-property">add</span>(arr[i]);<br>        &#125;<br><br>        <span class="hljs-comment">//收集</span><br>        <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(LinkedList&lt;Integer&gt; bucket : buckets)&#123;<br>            <span class="hljs-keyword">while</span>(!bucket.<span class="hljs-property">isEmpty</span>())&#123;<br>                arr[j++] = bucket.<span class="hljs-property">removeFirst</span>();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-built_in">exp</span> *= <span class="hljs-number">10</span>;<br>        digit--;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度为O(d*(n+k))，空间复杂度为O(n+k)，是一种<strong>稳定</strong>排序算法，其中d为最大值的位数，k为数字的<strong>基数</strong>（即桶的个数）。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>排序算法-选择排序与堆排序</title>
    <link href="/posts/4754/"/>
    <url>/posts/4754/</url>
    
    <content type="html"><![CDATA[<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>算法思路：找出待排序序列中最小的元素与序列的第一个元素进行交换，此时序列第一个元素为整个待排序序列的最小值。对剩余未排序元素重复这一过程，直到所有元素均有序。每进行一次交换，便有一个元素确定了最终的位置。</p><p>代码：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">selectSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span>; i++)&#123;<br>        <span class="hljs-type">int</span> min = i; <span class="hljs-comment">// 记录最小值的下标</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; arr.length; j++)&#123;<br>            <span class="hljs-keyword">if</span>(arr[j] &lt; arr[min])&#123;<br>                min = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(min != i)&#123;<br>            <span class="hljs-type">int</span> tmp = arr[i];<br>            arr[i] = arr[min];<br>            arr[min] = tmp;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度为O(n^2)，空间复杂度为O(1)，是一种<strong>不稳定</strong>排序算法。</p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆排序是利用<strong>堆</strong>（heap）这种数据结构设计的一种排序算法，是<strong>选择排序</strong>的一种。</p><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>堆是一种特殊的<strong>完全二叉树</strong>，它满足如下性质：<strong>任意子树父节点的值大于（或小于）子节点的值</strong>。当父节点的值大于子节点的值，称为<strong>大根堆</strong>；当父节点的值小于子节点的值，称为<strong>小根堆</strong>。</p><p>补充：具有n个节点的完全二叉树的性质：</p><ol><li>一个节点的下标为i（0&lt;&#x3D;i&lt;&#x3D;n-1）：<br>（1）如果<code>2*i+1 &lt; n</code>，则该节点存在左孩子，其下标为<code>2*i+1</code>；<br>（2）如果<code>2*i+2 &lt; n</code>，则该节点存在右孩子，其下标为<code>2*i+2</code>。</li><li>非叶子节点的下标范围为[0,n&#x2F;2 -1]， 叶子节点的下标范围为[n&#x2F;2, n-1]（注意下标均为整数）。</li></ol><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>算法思路：设序列中的元素数目为n。将序列构建成一个堆，然后将堆顶元素与末尾元素交换，此时末尾元素即为序列的最大值。重新调整堆的结构，使剩余n-1个元素其满足堆的定义。重复上述过程，直到所有元素均有序。</p><p>通常，升序排序使用大根堆，降序排序使用小根堆。下面以大根堆为例进行说明。</p><p><strong>步骤一：建堆</strong></p><p>从最后一个非叶子节点（下标为n&#x2F;2-1）开始进行调整，然后<strong>自下而上</strong>、<strong>自右向左</strong>找出所有的非叶子节点进行调整。</p><p>调整的过程就是判断父节点的值是否大于子节点，如果存在子节点的值大于父节点的情况，则将子节点中的最大值与父节点进行交换，并对进行交换的子节点所在的子树进行<strong>递归</strong>（或迭代）调整。</p><p><strong>步骤二：排序</strong></p><p>将堆顶元素与待排序序列末尾元素进行交换，此时末尾元素为整个待排序序列的最大值。然后调整堆，得到新的堆顶元素。每进行一次交换，便有一个元素确定了最终的位置。经过n-1次交换，所有元素完成排序。</p><p>完整代码（堆调整递归）：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public static void adjust<span class="hljs-constructor">Heap(<span class="hljs-params">int</span>[] <span class="hljs-params">arr</span>, <span class="hljs-params">int</span> <span class="hljs-params">i</span>, <span class="hljs-params">int</span> <span class="hljs-params">n</span>)</span>&#123;<br>    <span class="hljs-built_in">int</span> lChild = <span class="hljs-number">2</span><span class="hljs-operator"> * </span>i + <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">int</span> rChild = <span class="hljs-number">2</span><span class="hljs-operator"> * </span>i + <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">int</span> target = i;<br>    <span class="hljs-keyword">if</span>(lChild &lt; n<span class="hljs-operator"> &amp;&amp; </span>arr<span class="hljs-literal">[<span class="hljs-identifier">lChild</span>]</span> &gt; arr<span class="hljs-literal">[<span class="hljs-identifier">target</span>]</span>)&#123;<br>        target = lChild;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(rChild &lt; n<span class="hljs-operator"> &amp;&amp; </span>arr<span class="hljs-literal">[<span class="hljs-identifier">rChild</span>]</span> &gt; arr<span class="hljs-literal">[<span class="hljs-identifier">target</span>]</span>)&#123;<br>        target = rChild;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(target != i)&#123;<br>        swap(arr, i, target);<br>        adjust<span class="hljs-constructor">Heap(<span class="hljs-params">arr</span>, <span class="hljs-params">target</span>, <span class="hljs-params">n</span>)</span>; <span class="hljs-comment">// 调整对应的子树</span><br>    &#125;<br>&#125;<br><br>public static void swap(<span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> arr, <span class="hljs-built_in">int</span> i, <span class="hljs-built_in">int</span> j)&#123;<br>    <span class="hljs-built_in">int</span> tmp = arr<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>;<br>    arr<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = arr<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>;<br>    arr<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span> = tmp;<br>&#125;<br><br>public static void build<span class="hljs-constructor">Heap(<span class="hljs-params">int</span>[] <span class="hljs-params">arr</span>, <span class="hljs-params">int</span> <span class="hljs-params">n</span>)</span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = n<span class="hljs-operator"> / </span><span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>        adjust<span class="hljs-constructor">Heap(<span class="hljs-params">arr</span>, <span class="hljs-params">i</span>, <span class="hljs-params">n</span>)</span>;<br>    &#125;<br>&#125;<br><br>public static void heap<span class="hljs-constructor">Sort(<span class="hljs-params">int</span>[] <span class="hljs-params">arr</span>)</span>&#123;<br><br>    <span class="hljs-built_in">int</span> n = arr.length;<br><br>    <span class="hljs-comment">//构建大根堆</span><br>    build<span class="hljs-constructor">Heap(<span class="hljs-params">arr</span>, <span class="hljs-params">n</span>)</span>;<br><br>    <span class="hljs-comment">//将堆顶元素（即最大值）与待排序序列末尾元素交换，并调整堆</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = arr.length - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--)&#123;<br>        swap(arr, i , <span class="hljs-number">0</span>);<br>        adjust<span class="hljs-constructor">Heap(<span class="hljs-params">arr</span>, 0, <span class="hljs-params">i</span>)</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>堆调整非递归代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">adjustHeap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>; k &lt; n; k = <span class="hljs-number">2</span> * k + <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-comment">// k是最大子节点的下标</span><br>        <span class="hljs-keyword">if</span>(k + <span class="hljs-number">1</span> &lt; n &amp;&amp; arr[k] &lt; arr[k+<span class="hljs-number">1</span>])&#123; <span class="hljs-comment">//右孩子存在且值大于左孩子</span><br>            k++;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(arr[k] &gt; arr[i])&#123;<br>            <span class="hljs-built_in">swap</span>(arr, i, k);<br>            i = k;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度为O(nlogn)，空间复杂度为O(1)，是一种<strong>不稳定</strong>排序算法。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>排序算法-归并排序与快速排序</title>
    <link href="/posts/29757/"/>
    <url>/posts/29757/</url>
    
    <content type="html"><![CDATA[<h2 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h2><p>分治思想：对于一个难以解决的问题，将其划分为规模较小的子问题，这些子问题<strong>相互独立</strong>并且与原问题具有<strong>相同形式</strong>，递归求解子问题，然后将各子问题的解合并形成原问题的解。</p><p>分治法分为三个步骤：<br>1.分：将大问题分解为若干子问题<br>2.治：递归求解各个子问题（将子问题分为规模更小的问题，直到问题可以直接求解）<br>3.合：将子问题的解合并为原问题的解</p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序是<strong>分治</strong>法的一个典型应用。</p><p>算法思路：<br>1.分：将一个序列的排序问题转化为m个子序列的排序问题<br>2.治：以递归（或者迭代）形式，分别对m个子序列进行归并排序<br>3.合：将m个有序子序列进行合并，形成一个有序序列</p><p>当m&#x3D;2时，即为<strong>二路归并排序</strong>，其代码（递归形式）如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public static void merge<span class="hljs-constructor">Sort(<span class="hljs-params">int</span>[] <span class="hljs-params">arr</span>, <span class="hljs-params">int</span> <span class="hljs-params">low</span>, <span class="hljs-params">int</span> <span class="hljs-params">high</span>, <span class="hljs-params">int</span>[] <span class="hljs-params">tmp</span>)</span>&#123;<br>    <span class="hljs-keyword">if</span>(low &lt; high) &#123;<br>        <span class="hljs-built_in">int</span> mid = (low + high)<span class="hljs-operator"> / </span><span class="hljs-number">2</span>;<br><br>        <span class="hljs-comment">//将序列划分为两个子序列，分别进行归并排序</span><br>        merge<span class="hljs-constructor">Sort(<span class="hljs-params">arr</span>, <span class="hljs-params">low</span>, <span class="hljs-params">mid</span>, <span class="hljs-params">tmp</span>)</span>;<br>        merge<span class="hljs-constructor">Sort(<span class="hljs-params">arr</span>, <span class="hljs-params">mid</span> + 1, <span class="hljs-params">high</span>, <span class="hljs-params">tmp</span>)</span>;<br><br>        <span class="hljs-comment">//合并两个有序子序列</span><br>        merge(arr, low, mid, high, tmp);<br>    &#125;<br>&#125;<br><br>public static void merge(<span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> arr, <span class="hljs-built_in">int</span> low, <span class="hljs-built_in">int</span> mid, <span class="hljs-built_in">int</span> high, <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> tmp)&#123;<br>    <span class="hljs-built_in">int</span> i = low, j = mid + <span class="hljs-number">1</span>, k = low;<br>    <span class="hljs-keyword">while</span>(i &lt;= mid<span class="hljs-operator"> &amp;&amp; </span>j &lt;= high)&#123;<br>        <span class="hljs-keyword">if</span>(arr<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> &lt;= arr<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>)&#123;<br>            tmp<span class="hljs-literal">[<span class="hljs-identifier">k</span><span class="hljs-operator">++</span>]</span> = arr<span class="hljs-literal">[<span class="hljs-identifier">i</span><span class="hljs-operator">++</span>]</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            tmp<span class="hljs-literal">[<span class="hljs-identifier">k</span><span class="hljs-operator">++</span>]</span> = arr<span class="hljs-literal">[<span class="hljs-identifier">j</span><span class="hljs-operator">++</span>]</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(i &lt;= mid)&#123;<br>        tmp<span class="hljs-literal">[<span class="hljs-identifier">k</span><span class="hljs-operator">++</span>]</span> = arr<span class="hljs-literal">[<span class="hljs-identifier">i</span><span class="hljs-operator">++</span>]</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(j &lt;= high)&#123;<br>        tmp<span class="hljs-literal">[<span class="hljs-identifier">k</span><span class="hljs-operator">++</span>]</span> = arr<span class="hljs-literal">[<span class="hljs-identifier">j</span><span class="hljs-operator">++</span>]</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> m = low ; m &lt;= high; m++)&#123;<br>        arr<span class="hljs-literal">[<span class="hljs-identifier">m</span>]</span> = tmp<span class="hljs-literal">[<span class="hljs-identifier">m</span>]</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：辅助数组tmp需要预先创建，不能在函数mergeSort中创建，否则每一次递归都会创建一个新的辅助数组。</p><p>时间复杂度为O(nlogn)，空间复杂度为O(n)，是一种<strong>稳定</strong>排序算法。</p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>快速排序是对冒泡排序的改进，采用了<strong>分治</strong>思想。</p><p>算法思路：从序列中任选一个基准元素pivot，将序列按照pivot划分为两部分，即<strong>分区操作</strong>(partition)，左侧部分均小于等于基准元素pivot，右侧部分均大于等于基准元素，然后分别对这两个部分进行递归求解，最终形成有序序列。</p><p>经过一次分区操作，便有一个基准元素确定了最终的位置。实现分区操作的方法有多种，这里给出了两种方法，其中均选择序列第一个元素作为基准元素。</p><h3 id="“挖坑法”"><a href="#“挖坑法”" class="headerlink" title="“挖坑法”"></a>“挖坑法”</h3><p>实现思路：选定pivot后，其原始位置相当于空白。设定left和right分别表示序列首部和末尾。从右向左找小于pivot的元素，并将该元素与空白进行交换；然后从左向右找大于pivot的元素，并将该元素与空白进行交换。交替执行上述过程，逐渐缩小范围，直到left&#x3D;&#x3D;right，此时left处即为pivot的最终位置（left左侧元素均小于等于pivot，right右侧元素均大于等于pivot）。</p><p>代码：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public static void quick<span class="hljs-constructor">Sort(<span class="hljs-params">int</span>[] <span class="hljs-params">arr</span>, <span class="hljs-params">int</span> <span class="hljs-params">low</span>, <span class="hljs-params">int</span> <span class="hljs-params">high</span>)</span>&#123;<br>    <span class="hljs-keyword">if</span>(low &lt; high)&#123;<br>        <span class="hljs-built_in">int</span> i = partition(arr, low, high);<br>        quick<span class="hljs-constructor">Sort(<span class="hljs-params">arr</span>, <span class="hljs-params">low</span>, <span class="hljs-params">i</span>-1)</span>;<br>        quick<span class="hljs-constructor">Sort(<span class="hljs-params">arr</span>, <span class="hljs-params">i</span>+1, <span class="hljs-params">high</span>)</span>;<br>    &#125;<br>&#125;<br><br>public static <span class="hljs-built_in">int</span> partition(<span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> arr, <span class="hljs-built_in">int</span> low ,<span class="hljs-built_in">int</span> high)&#123;<br>    <span class="hljs-built_in">int</span> pivot = arr<span class="hljs-literal">[<span class="hljs-identifier">low</span>]</span>;<br>    <span class="hljs-built_in">int</span> left = low;<br>    <span class="hljs-built_in">int</span> right = high;<br>    <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>        <span class="hljs-comment">//从右向左找比pivot小的元素</span><br>        <span class="hljs-keyword">while</span>(left &lt; right<span class="hljs-operator"> &amp;&amp; </span>arr<span class="hljs-literal">[<span class="hljs-identifier">right</span>]</span> &gt;= pivot)&#123;<br>            right--; <span class="hljs-comment">// right右侧元素均大于等于pivot</span><br>        &#125;<br>        arr<span class="hljs-literal">[<span class="hljs-identifier">left</span>]</span> = arr<span class="hljs-literal">[<span class="hljs-identifier">right</span>]</span>;<br><br>        <span class="hljs-comment">//从左向右找比pivot大的元素</span><br>        <span class="hljs-keyword">while</span>(left &lt; right<span class="hljs-operator"> &amp;&amp; </span>arr<span class="hljs-literal">[<span class="hljs-identifier">left</span>]</span> &lt;= pivot) &#123;<br>            left++; <span class="hljs-comment">// left左侧元素均小于等于pivot</span><br>        &#125;<br>        arr<span class="hljs-literal">[<span class="hljs-identifier">right</span>]</span> = arr<span class="hljs-literal">[<span class="hljs-identifier">left</span>]</span>;<br>    &#125;<br>    arr<span class="hljs-literal">[<span class="hljs-identifier">left</span>]</span> = pivot;<br>    return left;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：判断条件<code>while(left &lt; right &amp;&amp; arr[right] &gt;= pivot)</code>和<code>while(left &lt; right &amp;&amp; arr[left] &lt;= pivot)</code>中至少有一个含有等号。如果不加等号，则在含有重复元素的情况下会出现死循环，比如当前right位置的元素值等于pivot，则将right处元素赋值给left处元素，然后判断left处元素不小于pivot，再将left处元素赋值给right处元素，从而left和right处元素一直交换，形成死循环。</p><h3 id="快慢指针法"><a href="#快慢指针法" class="headerlink" title="快慢指针法"></a>快慢指针法</h3><p>实现思路：分别设置快指针cur和慢指针pre。cur向右查找小于pivot的元素，pre向右移动一位，将该元素与pre处的元素进行交换。当cur查完整个序列时，pre即为基准元素pivot的最终位置（pre及其左侧（不包含low处元素）均为小于pivot的元素，pre右侧到cur左侧均为大于等于pivot的元素）。如图所示。</p><p><img src="/../images/sort/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%E6%B3%95.png" alt="快慢指针法"></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">partition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> low ,<span class="hljs-type">int</span> high)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">pivot</span> <span class="hljs-operator">=</span> arr[low];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> low;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> pre + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(cur &lt;= high)&#123;<br>        <span class="hljs-keyword">if</span>(arr[cur] &lt; pivot)&#123;<br>            pre++;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> arr[pre];<br>            arr[pre] = arr[cur];<br>            arr[cur] = tmp;<br>        &#125;<br>        cur++;<br>    &#125;<br>    arr[low] = arr[pre];<br>    arr[pre] = pivot;<br>    <span class="hljs-keyword">return</span> pre;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：最后需要将pre与low处的基准元素进行交换，不能遗漏。</p><h3 id="优化与分析"><a href="#优化与分析" class="headerlink" title="优化与分析"></a>优化与分析</h3><p>快速排序的时间性能取决于基准元素pivot的选择。如果每次都选择最小或者最大的元素作为基准元素，则快速排序的时间复杂度会退化为为O(n^2)。为了减少最坏情况下的时间复杂度，通常使用“三数取中法”选择基准元素。</p><p>“<strong>三数取中法</strong>”：比较序列首部、末尾和中间元素，选择中间值作为基准元素。</p><p>时间复杂度为O(nlogn)，空间复杂度为O(logn)，是一种<strong>不稳定</strong>排序算法。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>排序算法-插入排序与希尔排序</title>
    <link href="/posts/1110/"/>
    <url>/posts/1110/</url>
    
    <content type="html"><![CDATA[<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>算法思路：将当前序列分为有序和待排序（无序）两部分，找到每一个待排序元素在有序序列中的位置，将其插入到有序序列中，并将之后的所有元素向后移动一个单位，形成一个新的有序序列。重复这一过程，直到所有元素均有序。初始时将第一个元素视为有序序列。如图所示。</p><p><img src="/../images/sort/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.png" alt="插入排序"></p><p>代码：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">insertSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt; arr.length; i++)&#123;<br>        <span class="hljs-comment">// i左侧的元素均处于有序状态</span><br>        <span class="hljs-type">int</span> tmp = arr[i];<br>        <span class="hljs-type">int</span> j = i<span class="hljs-number">-1</span>; <br>        <span class="hljs-keyword">while</span>(j &gt;= <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>(tmp &lt; arr[j])&#123;<br>                <span class="hljs-comment">// 如果待插入元素的值小于j处元素，则将j处元素向后移动一个位置</span><br>                arr[j+<span class="hljs-number">1</span>] = arr[j];<br>                j--;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 如果待插入元素的值大于等于j处元素，则j+1即表示待插入位置</span><br>        &#125;<br>        arr[j+<span class="hljs-number">1</span>] = tmp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度O(n^2)，空间复杂度O(1)，是一种<strong>稳定</strong>排序算法。在<strong>局部有序</strong>的情况下，效率较高；而在数据完全无序的情况下，效率很低。</p><h3 id="二分插入排序"><a href="#二分插入排序" class="headerlink" title="二分插入排序"></a>二分插入排序</h3><p>算法思路:在直接插入排序的基础上，使用<strong>二分查找</strong>算法找出待插入元素在<strong>有序</strong>序列中的位置，如果存在重复元素，则需要找出其<strong>右边界</strong>。</p><p>代码：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs excel">public static void binaryInsertSort(<span class="hljs-built_in">int</span>[] arr)&#123;<br>    for(<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt; arr.length; i++)&#123;<br>        // i左侧的元素均处于有序状态<br><br>        //二分查找找出待插入位置<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span> = <span class="hljs-number">0</span>, <span class="hljs-built_in">right</span> = i-<span class="hljs-number">1</span>;<br>        while(<span class="hljs-built_in">left</span> &lt;= <span class="hljs-built_in">right</span>)&#123;<br>            <span class="hljs-built_in">int</span> <span class="hljs-built_in">mid</span> = (<span class="hljs-built_in">left</span> + <span class="hljs-built_in">right</span>) / <span class="hljs-number">2</span>;<br>            <span class="hljs-built_in">if</span>(arr[<span class="hljs-built_in">mid</span>] &lt;= arr[i]) <span class="hljs-built_in">left</span> = <span class="hljs-built_in">mid</span> + <span class="hljs-number">1</span>;<br>            else <span class="hljs-built_in">right</span> = <span class="hljs-built_in">mid</span> - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-built_in">int</span> target = <span class="hljs-built_in">left</span>;<br>        <span class="hljs-built_in">int</span> tmp = arr[i];<br>        for(<span class="hljs-built_in">int</span> j = i-<span class="hljs-number">1</span>; j &gt;= target; j--)&#123;<br>            arr[j+<span class="hljs-number">1</span>] = arr[j];<br>        &#125;<br>        arr[target] = tmp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>二分插入排序减少了比较次数，在特定的情况下提高了排序效率。然而其时间复杂度仍然为O(n^2)，是一种<strong>稳定</strong>排序算法。</p><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>希尔排序是插入排序的一种，又称缩小增量排序。</p><p>算法思路：给定增量gap，将下标为i + k * gap 的元素分为一组(其中k &#x3D; 1,2,3……n 且 i &#x3D; 0,1,2…… gap-1 且 i + k * gap &lt; 序列长度L)，一共分为gap组。对每一个分组分别使用<strong>直接插入排序</strong>，缩减增量值，重复这一过程。当增量值为1时，所有元素为一组进行直接插入排序，算法终止，所有元素均有序。如图所示。</p><p><img src="/../images/sort/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.png" alt="希尔排序"></p><p>注意：关于最优增量序列的选择至今尚未解决，通常情况下，选择初始增量为序列长度L的一半，增量值每一轮减半。</p><p>代码：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">shellSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span></span>&#123;<br>    <span class="hljs-type">int</span> gap = arr.length / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">while</span>(gap != <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; gap; i++)&#123;<br>            <span class="hljs-comment">// 同一组元素进行直接插入排序</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i + gap; j &lt; arr.length; j += gap)&#123;<br>                <span class="hljs-type">int</span> tmp = arr[j];<br>                <span class="hljs-type">int</span> k = j - gap;<br>                <span class="hljs-keyword">while</span>(k &gt;= <span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-keyword">if</span>(tmp &lt; arr[k])&#123;<br>                        arr[k + gap] = arr[k];<br>                        k -= gap;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>                &#125;<br>                arr[k + gap] = tmp;<br>            &#125;<br>        &#125;<br>        gap /= <span class="hljs-number">2</span>; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>希尔排序的时间复杂度目前尚未研究清楚，其执行时间依赖于增量序列，但是其时间性能优于直接插入排序，空间复杂度是O(1)，是一种<strong>不稳定</strong>排序算法。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>排序算法-冒泡排序</title>
    <link href="/posts/61237/"/>
    <url>/posts/61237/</url>
    
    <content type="html"><![CDATA[<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>算法思路：以升序为例，依次比较相邻两个元素，如果第一个元素的值大于第二个元素，则交换两个元素的值，直到处理完序列中最后两个元素，即为一轮，此时最后一个元素的值即为最大值（即处于有序状态）。重复这一过程，直到所有元素都处于有序状态。如图所示。</p><p><img src="/../images/sort/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.png" alt="冒泡排序"></p><p>代码（java）：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = arr.length<span class="hljs-number">-1</span>; i &gt; <span class="hljs-number">0</span>; i--)&#123;<br>        <span class="hljs-comment">// i后面的元素均处于有序状态</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++)&#123;<br>            <span class="hljs-keyword">if</span>(arr[j] &gt; arr[j+<span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-type">int</span> tmp = arr[j];<br>                arr[j] = arr[j+<span class="hljs-number">1</span>];<br>                arr[j+<span class="hljs-number">1</span>] = tmp;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度O(n^2)，空间复杂度O(1)，是一种<strong>稳定</strong>排序算法。</p><h2 id="冒泡排序的改进"><a href="#冒泡排序的改进" class="headerlink" title="冒泡排序的改进"></a>冒泡排序的改进</h2><p>如果在某一轮中没有发生元素值的交换，则说明序列已经处于有序状态，无需再继续进行循环。设置一个标记flag&#x3D;true，只要发生元素值的交换就将flag置为false。在一轮结束后，如果flag仍然为true，则说明序列已经有序，终止循环。</p><p>改进后的代码：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">bubbleSortImprove</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = arr.length<span class="hljs-number">-1</span>; i &gt; <span class="hljs-number">0</span>; i--)&#123;<br>        <span class="hljs-comment">// i后面的元素均处于有序状态</span><br>        <span class="hljs-type">boolean</span> flag = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 标记序列是否有序</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++)&#123;<br>            <span class="hljs-keyword">if</span>(arr[j] &gt; arr[j+<span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-type">int</span> tmp = arr[j];<br>                arr[j] = arr[j+<span class="hljs-number">1</span>];<br>                arr[j+<span class="hljs-number">1</span>] = tmp;<br>                flag = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(flag) <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="双向冒泡排序"><a href="#双向冒泡排序" class="headerlink" title="双向冒泡排序"></a>双向冒泡排序</h2><p>双向冒泡排序，又称鸡尾酒排序，是冒泡排序的一种改进。</p><p>算法步骤：<br>1.从左到右依次比较相邻的两个元素，直到将最大值移动至序列末尾。<br>2.从右向左依次比较相邻的两个元素，直到将最小值移动至序列头部。<br>3.重复上述过程，直到序列中只剩一个元素，即完成排序。</p><p>代码：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">cocktailSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span></span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = arr.length<span class="hljs-number">-1</span>;<br>    <span class="hljs-comment">//left左侧和right右侧的元素均处于有序状态</span><br>    <span class="hljs-type">boolean</span> flag = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br><br>        flag = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-comment">//从左向右移动最大值至right处</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = left; i &lt; right; i++)&#123;<br>            <span class="hljs-keyword">if</span>(arr[i] &gt; arr[i+<span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-type">int</span> tmp = arr[i];<br>                arr[i] = arr[i+<span class="hljs-number">1</span>];<br>                arr[i+<span class="hljs-number">1</span>] = tmp;<br>                flag = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        right--;<br><br>        <span class="hljs-comment">//从右向左移动最小值至left处</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = right; j &gt; left; j--)&#123;<br>            <span class="hljs-keyword">if</span>(arr[j<span class="hljs-number">-1</span>] &gt; arr[j])&#123;<br>                <span class="hljs-type">int</span> tmp = arr[j<span class="hljs-number">-1</span>];<br>                arr[j<span class="hljs-number">-1</span>] = arr[j];<br>                arr[j] = tmp;<br>                flag = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        left++;<br><br>        <span class="hljs-keyword">if</span>(flag) <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>基于Tensorflow的MNIST手写数字识别</title>
    <link href="/posts/42525/"/>
    <url>/posts/42525/</url>
    
    <content type="html"><![CDATA[<p>任务描述：识别给定图像中的数字，数字范围为0到9。实际上是一个<strong>多分类</strong>任务。</p><h3 id="MNIST数据集"><a href="#MNIST数据集" class="headerlink" title="MNIST数据集"></a>MNIST数据集</h3><p>图像的大小为28*28，标签范围为0到9，训练集图片的数量为60000，测试集图片的数量为10000。keras中提供了该数据集，能够直接导入使用。</p><h3 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h3><p>1.对图像进行扁平化处理，将图像维度由28*28转化为行向量。<br>2.进行归一化处理。对于图像数据，直接用像素值除以255。<br>3.对于多分类任务，需要将标签转化为<strong>one-hot编码</strong>。</p><h3 id="模型结构"><a href="#模型结构" class="headerlink" title="模型结构"></a>模型结构</h3><p>网络结构为三层，均为全连接层。前两层均为20个神经元，激活函数均为relu；最后一层为10个神经元（对应分类数目），激活函数使用softmax。</p><h3 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h3><p>采用Adam算法进行梯度下降，损失函数选用交叉熵损失，评价指标选择准确率（accuracy）</p><p>代码如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs routeros">import numpy as np<br>import tensorflow as tf<br><span class="hljs-keyword">from</span> tensorflow import keras<br><span class="hljs-keyword">from</span> keras.datasets import mnist<br><span class="hljs-keyword">from</span> keras.utils import to_categorical<br><span class="hljs-keyword">from</span> PIL import Image<br><br><span class="hljs-comment"># ----------------------</span><br><span class="hljs-comment"># 数据集处理</span><br><span class="hljs-comment"># ----------------------</span><br><br>(train_images, train_labels), (test_images, test_labels) = mnist.load_data()<br><span class="hljs-comment"># 数据格式为np.ndarray 图像形状为(num,28,28) 标签形状为(num,)</span><br><br><span class="hljs-comment"># img = Image.fromarray(test_images[2341])</span><br><span class="hljs-comment"># img.show()</span><br><span class="hljs-comment"># img.save(&quot;./images/image.jpg&quot;)</span><br><br><span class="hljs-comment"># 扁平化处理 </span><br>dim = train_images.shape[1] * train_images.shape[2] # 输入到网络中的数据的维度<br>train_images = train_images.reshape((train_images.shape[0], -1))<br>test_images = test_images.reshape((test_images.shape[0], -1))<br><br><span class="hljs-comment"># 归一化处理</span><br>train_images = train_images / 255<br>test_images = test_images / 255<br><br><span class="hljs-comment">#将标签转化为one-hot编码</span><br>train_labels = to_categorical(train_labels.reshape(-1,1), <span class="hljs-attribute">num_classes</span>=10)<br>test_labels = to_categorical(test_labels.reshape(-1,1), <span class="hljs-attribute">num_classes</span>=10)<br><br><span class="hljs-comment"># -----------------------</span><br><span class="hljs-comment"># 模型构建</span><br><span class="hljs-comment"># -----------------------</span><br><br>model = keras.models.Sequential([<br>    keras.layers.Dense(<span class="hljs-attribute">units</span>=20, input_shape=(dim, )),    # 全连接层<br>    keras.layers.ReLU(),<br>    keras.layers.Dense(<span class="hljs-attribute">units</span>=20),    # 全连接层<br>    keras.layers.ReLU(),<br>    keras.layers.Dense(<span class="hljs-attribute">units</span>=10,activation=&quot;softmax&quot;)  # 全连接+softmax<br>])<br><span class="hljs-comment"># model.summary() # 查看网络结构</span><br><br><span class="hljs-comment"># 模型装配</span><br>lr = 0.001<br>model.compile(<span class="hljs-attribute">optimizer</span>=keras.optimizers.Adam(learning_rate=lr),<br>              loss = keras.losses.CategoricalCrossentropy(),<br>              metrics=[<span class="hljs-string">&#x27;accuracy&#x27;</span>])<br><span class="hljs-comment"># 也可以使用字符串形式传递</span><br><span class="hljs-comment"># 如 optimizer = “rmsprop”, loss = &#x27;categorical_crossentropy&#x27;)</span><br><br><span class="hljs-comment"># 模型训练</span><br>num_epochs = 100<br>minibatch_size = 50<br>history = model.fit(train_images, train_labels, <span class="hljs-attribute">epochs</span>=num_epochs, <span class="hljs-attribute">batch_size</span>=minibatch_size)<br><br>train_loss = history.history[<span class="hljs-string">&#x27;loss&#x27;</span>]<br>train_accuracy = history.history[<span class="hljs-string">&#x27;accuracy&#x27;</span>]<br><br><span class="hljs-comment"># 在tensorboard中绘制loss曲线和accuracy曲线</span><br>log_dir = <span class="hljs-string">&quot;./logs/&quot;</span><br>writer = tf.summary.create_file_writer(log_dir)<br>with writer.as_default():<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(num_epochs):<br>        tf.summary.scalar(<span class="hljs-string">&#x27;train_loss&#x27;</span>, train_loss[i], <span class="hljs-attribute">step</span>=i)<br>        tf.summary.scalar(<span class="hljs-string">&#x27;accuracy&#x27;</span>, train_accuracy[i], <span class="hljs-attribute">step</span>=i)<br>writer.flush()<br>writer.close()<br><br><span class="hljs-comment"># 模型评估</span><br>_, test_accuracy = model.evaluate(test_images, test_labels)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;test accuracy:&quot;</span> + str(test_accuracy))<br><br><span class="hljs-comment"># 模型测试</span><br>image = Image.open(<span class="hljs-string">&quot;./images/image.jpg&quot;</span>)<br>image_array = np.array(image).reshape(1,-1)<br>result = model.predict(image_array)<br><span class="hljs-built_in">print</span>(result)<br></code></pre></td></tr></table></figure><p>在终端中使用<code>tensorboard --logdir=logs</code>，之后在localhost:6006端口（默认端口）即可查看绘制的曲线，如下图所示。</p><p><img src="/../images/deeplearning/tensorflow%E5%AE%9E%E7%8E%B0%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png" alt="训练损失train_loss和准确率accuracy曲线"></p><p>思考过程：数据集处理——网络搭建——模型改进</p><p>改进时可以调整层数、神经元数量、学习率、训练轮次等因素。对于该模型，增加神经元数量的提升效果最显著。</p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Anaconda常用命令</title>
    <link href="/posts/29299/"/>
    <url>/posts/29299/</url>
    
    <content type="html"><![CDATA[<h2 id="anaconda命令"><a href="#anaconda命令" class="headerlink" title="anaconda命令"></a>anaconda命令</h2><ol><li>查看anaconda中的全部环境</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda <span class="hljs-built_in">env</span> list<br></code></pre></td></tr></table></figure><ol start="2"><li>创建虚拟环境</li></ol><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">conda create -n 环境名 python<span class="hljs-operator">=</span><span class="hljs-keyword">x</span>.<span class="hljs-keyword">x</span>.<span class="hljs-keyword">x</span><br></code></pre></td></tr></table></figure><ol start="3"><li>激活虚拟环境</li></ol><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">conda <span class="hljs-built_in">activate</span> 环境名<br></code></pre></td></tr></table></figure><p>linux系统需要先激活base</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">source <span class="hljs-built_in">activate</span><br></code></pre></td></tr></table></figure><ol start="4"><li>查看当前虚拟环境中有哪些库</li></ol><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">conda list</span><br></code></pre></td></tr></table></figure><ol start="5"><li>退出虚拟环境</li></ol><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">conda deactivate</span><br></code></pre></td></tr></table></figure><ol start="6"><li>删除虚拟环境</li></ol><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">conda <span class="hljs-built_in">remove</span> -n 环境名 –all<br></code></pre></td></tr></table></figure><ol start="7"><li>切换工作目录</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /d 路径<br></code></pre></td></tr></table></figure><h2 id="Jupyter-Notebook添加虚拟环境"><a href="#Jupyter-Notebook添加虚拟环境" class="headerlink" title="Jupyter Notebook添加虚拟环境"></a>Jupyter Notebook添加虚拟环境</h2><ol><li>安装ipykernel</li></ol><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">conda <span class="hljs-keyword">install</span> ipykernel<br></code></pre></td></tr></table></figure><ol start="2"><li>将虚拟环境添加到Jupyter Notebook</li></ol><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">python -m ipykernel <span class="hljs-keyword">install</span> –name 环境名<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python异常与文件</title>
    <link href="/posts/51459/"/>
    <url>/posts/51459/</url>
    
    <content type="html"><![CDATA[<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="异常处理机制"><a href="#异常处理机制" class="headerlink" title="异常处理机制"></a>异常处理机制</h3><p>Python程序通过了解释但是在执行时报错，这类错误即为异常。异常处理是通过try-except实现的。程序停止执行并提示错误信息即为抛出异常。异常捕获的完整语法如下：</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs nim"><span class="hljs-keyword">try</span>:<br>    <span class="hljs-comment">#尝试执行的代码</span><br><span class="hljs-keyword">except</span> 错误类型<span class="hljs-number">1</span>:<br>    <span class="hljs-comment">#对应的代码处理</span><br><span class="hljs-keyword">except</span> (错误类型<span class="hljs-number">2</span>，错误类型<span class="hljs-number">3</span>):<br>    <span class="hljs-comment">#对应的代码处理</span><br><span class="hljs-keyword">except</span> <span class="hljs-type">Exception</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">result</span>:<br>    <span class="hljs-comment">#打印错误信息，result为捕获的异常对象</span><br>    print(<span class="hljs-built_in">result</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-comment">#没有异常才会执行的代码</span><br><span class="hljs-keyword">finally</span>:<br>    <span class="hljs-comment">#无论是否异常，都会执行的代码</span><br></code></pre></td></tr></table></figure><h3 id="异常传递"><a href="#异常传递" class="headerlink" title="异常传递"></a>异常传递</h3><p>当函数执行出现异常，会将异常传递给函数的调用者。利用异常的传递性，在主程序捕获异常，不需要在每个函数中增加异常捕获的代码。Python中提供了Exception异常类。<br>主动抛出异常的方法：<br>1.创建一个Exception的对象<br>2.使用<strong>raise</strong>关键字抛出异常对象</p><p>示例如下：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs vim">def input_password():<br>    <span class="hljs-keyword">pwd</span> = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入密码：&quot;</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(<span class="hljs-keyword">pwd</span>) &gt;= <span class="hljs-number">8</span>:<br>        <span class="hljs-keyword">print</span>(<span class="hljs-string">&quot;密码格式正确&quot;</span>)<br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">ex</span> = Exception(<span class="hljs-string">&quot;密码长度小于8位&quot;</span>)<br>        raise <span class="hljs-keyword">ex</span><br><br><span class="hljs-keyword">try</span>:<br>    input_password()<br>except Exception <span class="hljs-keyword">as</span> result:<br>    <span class="hljs-keyword">print</span>(<span class="hljs-string">&quot;程序异常：%s&quot;</span> % result)<br></code></pre></td></tr></table></figure><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><h3 id="1-模块"><a href="#1-模块" class="headerlink" title="1.模块"></a>1.模块</h3><p><strong>一个Python文件就是一个模块</strong>。模块提供的工具有全局变量、函数、类等。</p><p>导入方式：<br>（1）整个模块导入<br><code>import 模块名 as 模块别名</code><br>as关键字指定别名（可以省略），模块别名应满足“大驼峰“命名规则，通过<code>模块名.</code>的方式使用工具。</p><p>（2）部分导入工具<br><code>from 模块名 import 工具名</code><br>可以直接使用工具</p><p>注意：</p><ol><li><p>如果两个模块存在同名函数，后导入模块的函数会覆盖先导入模块的函数。</p></li><li><p>文件被导入时没有缩进的代码会被执行一遍。但是在实际开发中，模块下方可能会有一些测试代码，当被导入其他模块中执行时，这一部分代码也会被执行。可以通过__name__解决这一问题。<br><strong>name__是Python内置的一个字符串，存储模块的名称，可以用来标记当前模块是否为顶层模块。如果一个模块是顶层模块，即当前模块直接运行（没有被其他模块调用），__name</strong> &#x3D;&#x3D; “__main__”；而当前模块被导入到其他模块调用时，__name__为当前模块名。</p></li></ol><h3 id="2-包"><a href="#2-包" class="headerlink" title="2.包"></a>2.包</h3><p><strong>一个包是若干个模块的集合</strong>。实质是一个包含多个模块的特殊目录，目录下包含一个__init__.py文件，需要在该文件中指定对外界提供的模块列表。</p><p>包的命名规范为：全部小写字母，不推荐使用下划线。</p><p>包的结构为<strong>树状</strong>，可以进行分层组织，从而避免重名。例如一个包pkga的结构如下所示，它由两个子包pkgb和pkgc组成，两个子包都有同名模块module1。</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">pkga      <span class="hljs-comment">#顶层包a</span><br>|<span class="hljs-string">—— __init__.py</span><br><span class="hljs-string"></span>|<span class="hljs-string">—— pkgb        #子包b</span><br><span class="hljs-string"></span>|<span class="hljs-string">   </span>|<span class="hljs-string">—— __init__.py</span><br><span class="hljs-string"></span>|<span class="hljs-string">   </span>|<span class="hljs-string">—— module1.py</span><br><span class="hljs-string"></span>|<span class="hljs-string">   </span>|<span class="hljs-string">—— module2.py</span><br><span class="hljs-string"></span>|<br>|<span class="hljs-string">—— pkgc        #子包c</span><br><span class="hljs-string">    </span>|<span class="hljs-string">—— __init__.py</span><br><span class="hljs-string">    </span>|<span class="hljs-string">—— module1.py</span><br><span class="hljs-string">    </span>|<span class="hljs-string">—— module3.py</span><br></code></pre></td></tr></table></figure><p>如果要使用module2中的函数say()，则导入与使用方式如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs stylus">#方式一：<br>import pkga<span class="hljs-selector-class">.pkgb</span><span class="hljs-selector-class">.module2</span><br>pkga<span class="hljs-selector-class">.pkgb</span><span class="hljs-selector-class">.module2</span><span class="hljs-selector-class">.say</span>()<br><br>#方式二（推荐）：<br>from pkga<span class="hljs-selector-class">.pkgb</span> import module2<br>module2<span class="hljs-selector-class">.say</span>()<br><br>#方式三：<br>from pkga<span class="hljs-selector-class">.pkgb</span><span class="hljs-selector-class">.module2</span> import say<br><span class="hljs-function"><span class="hljs-title">say</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python面向对象-继承与多态</title>
    <link href="/posts/27884/"/>
    <url>/posts/27884/</url>
    
    <content type="html"><![CDATA[<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>类的继承可以实现代码的重用和扩展，主要通过子类（派生类）继承父类（基类）的属性和方法。</p><p>在Python中，子类可以继承多个父类，此时子类具有所有父类的属性和方法，这种继承方式称为<strong>多继承</strong>。语法格式为：<code>class 子类名(父类名1, 父类名2, ...)：</code></p><p>注意：<br>1.如果父类之间存在同名的属性或方法，应尽量避免使用多继承。<br>2.多个父类中，如果有同名的成员，那么默认以继承顺序（从左到右）为优先级。即：先继承的保留，后继承的被覆盖。<br>3.子类不能在自己的方法内部直接访问父类的私有属性或方法；子类对象可以通过父类的公有方法间接访问私有属性或方法。<br>4.<strong>object</strong>类是Python为所有对象提供的基类，有一些内置的属性和方法，可以使用dir函数查看。如果没有指定父类，则默认指定object类作为基类。</p><h2 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h2><p>子类可以创建自己独有的属性和方法，也可以重写父类的方法，以实现子类的特定需求。</p><p>重写（<strong>Override</strong>）即在子类中定义父类中已有的方法。通过子类对象调用该方法时，将执行子类的方法，不会调用父类的方法；如果要使用被重写的父类方法，则需要按照<code>super().父类方法名</code>的格式进行调用。</p><p>示例如下：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span>, name</span>):<br>        <span class="hljs-variable language_">self</span>.name = name<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):<br>        print(<span class="hljs-string">&quot;Animal:吃东西&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hunt</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):<br>        print(<span class="hljs-string">&quot;Animal:捕猎&quot;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-title class_">Animal</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):<br>        print(<span class="hljs-string">&quot;Dog%s:吃东西&quot;</span> % <span class="hljs-variable language_">self</span>.name)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hunt</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):<br>        <span class="hljs-comment"># 调用父类的方法 </span><br>        <span class="hljs-variable language_">super</span>().hunt()<br>        print(<span class="hljs-string">&quot;Dog%s:捕猎&quot;</span> % <span class="hljs-variable language_">self</span>.name)<br><br>dog=<span class="hljs-title class_">Dog</span>(<span class="hljs-string">&quot;旺财&quot;</span>)<br>dog.eat()<br>dog.hunt()<br></code></pre></td></tr></table></figure><p>结果：Dog旺财:吃东西 Animal:捕猎 Dog旺财:捕猎</p><p>注意：super函数可以使用父类的所有非私有方法（包括类方法、实例方法、静态方法）。</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态即不同的子类对象调用相同的父类方法时，会产生不同的执行结果，一般通过继承和重写实现。</p><p>Python中的多态与Java等强类型语言不同，即”<strong>鸭子类型</strong>“。在鸭子类型中，关注点在于对象是否具有调用的方法，而不是关注对象所属的类型。</p><p>示例如下：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">class</span> <span class="hljs-variable">Animal</span>:<br>    <span class="hljs-variable">def</span> <span class="hljs-function"><span class="hljs-title">eat</span>(<span class="hljs-variable">self</span>):</span><br><span class="hljs-function">        <span class="hljs-title">print</span>(<span class="hljs-string">&quot;Animal:吃东西&quot;</span>)</span><br><br><span class="hljs-variable">class</span> <span class="hljs-function"><span class="hljs-title">Dog</span>(<span class="hljs-variable">Animal</span>):</span><br><span class="hljs-function">    <span class="hljs-variable">def</span> <span class="hljs-title">eat</span>(<span class="hljs-variable">self</span>):</span><br><span class="hljs-function">        <span class="hljs-title">print</span>(<span class="hljs-string">&quot;Dog:吃东西&quot;</span>)</span><br><br><span class="hljs-variable">class</span> <span class="hljs-function"><span class="hljs-title">Bird</span>(<span class="hljs-variable">Animal</span>):</span><br><span class="hljs-function">    <span class="hljs-variable">def</span> <span class="hljs-title">eat</span>(<span class="hljs-variable">self</span>):</span><br><span class="hljs-function">        <span class="hljs-title">print</span>(<span class="hljs-string">&quot;Bird:吃东西&quot;</span>)</span><br><br><span class="hljs-variable">def</span> <span class="hljs-function"><span class="hljs-title">eat_food</span>(<span class="hljs-variable">animal</span>:<span class="hljs-variable">Animal</span>):</span><br><span class="hljs-function">    <span class="hljs-variable">animal.eat</span>()</span><br><br><span class="hljs-variable">dog</span> = <span class="hljs-function"><span class="hljs-title">Dog</span>()</span><br><span class="hljs-variable">bird</span> = <span class="hljs-function"><span class="hljs-title">Bird</span>()</span><br><span class="hljs-function"><span class="hljs-title">eat_food</span>(<span class="hljs-variable">dog</span>)</span><br><span class="hljs-function"><span class="hljs-title">eat_food</span>(<span class="hljs-variable">bird</span>)</span><br></code></pre></td></tr></table></figure><p>结果：Dog:吃东西 Bird:吃东西</p><h2 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h2><p>单例设计模式即使用类创建的对象在系统中只有唯一的一个实例。为了实现单例设计模式，需要重写__new__方法，在每次创建对象时只会得到第一次创建对象的引用。但是在这一过程中，__init__方法会被多次调用，因此需要使用一个标记来判断是否执行。</p><p>示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MusicPlayer</span>:<br><br>    <span class="hljs-comment"># 使用类属性保存创建第一个对象的内存空间</span><br>    instance = <span class="hljs-literal">None</span><br><br>    <span class="hljs-comment"># 使用类属性标记是否执行过初始化方法</span><br>    init_flag = <span class="hljs-literal">False</span><br><br>    <span class="hljs-comment"># 重写__new__方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, *args, **kwargs</span>):<br>        <span class="hljs-comment"># 判断类属性是否为空</span><br>        <span class="hljs-keyword">if</span> cls.instance <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-comment"># 调用父类方法为第一对象分配内存空间</span><br>            cls.instance = <span class="hljs-built_in">super</span>().__new__(cls)<br>        <span class="hljs-keyword">return</span> cls.instance<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> MusicPlayer.init_flag:<br>            MusicPlayer.init_flag = <span class="hljs-literal">True</span><br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;初始化播放&quot;</span>)<br><br>player1 = MusicPlayer()<br><span class="hljs-built_in">print</span>(player1)<br>player2 = MusicPlayer()<br><span class="hljs-built_in">print</span>(player2)<br></code></pre></td></tr></table></figure><p>结果为：初始化播放<br>&lt;__ main __ .MusicPlayer object at 0x000001D100C10160&gt;<br>&lt; __ main __.MusicPlayer object at 0x000001D100C10160&gt;</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python面向对象-类的封装</title>
    <link href="/posts/18439/"/>
    <url>/posts/18439/</url>
    
    <content type="html"><![CDATA[<h2 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h2><blockquote><p>在Python3中，一切皆为对象。</p></blockquote><p>类是一种抽象的数据结构，是对一类具有共同特征的事物的抽象，而对象是对类的实例化。<strong>对象的本质是一块内存空间</strong>。类的定义与对象的创建如下所示：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-comment"># 定义一个Hello类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Hello</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">say_hello</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):<br>        print(<span class="hljs-string">&quot;Hello world!&quot;</span>)<br>        <br><span class="hljs-comment"># 创建对象</span><br>hello_python = <span class="hljs-title class_">Hello</span>()<br>hello_python.say_hello()<br></code></pre></td></tr></table></figure><p>注意：<br>1.self是对调用方法的对象自身的引用，<strong>实例方法的第一个参数必须为self</strong><br>2.调用实例方法时并不需要传递self参数<br>3.变量与对象的关系：变量的本质是系统表中的一个元素，用来指向对象，是<strong>对象的引用</strong>，而不是对象本身。</p><p>内置函数dir可以查看对象内的所有属性和方法，传入参数为标识符&#x2F;数据。<strong>None</strong>关键字表示空对象，是一个特殊的常量（与C++中的nullptr类似），常与is连用。</p><p><strong>is</strong>与<strong>is not</strong>是身份运算符，用于比较两个对象的内存地址（id）是否一致。对于is而言，如果两个变量的引用对象为同一个，则返回true，反之返回false，is not则相反。注意与&#x3D;&#x3D;运算符的区别，&#x3D;&#x3D;运算符比较的是两个对象的值是否相同，如下图所示：</p><p><img src="/../images/Python/%E7%B1%BB%E7%9A%84%E5%B0%81%E8%A3%85-%E8%BF%90%E7%AE%97%E7%AC%A6%E5%8C%BA%E5%88%AB.png" alt="is与==运算符的区别"></p><p>从这一例子也可以看出，可变数据类型与不可变类型在内存分配方式上的不同。<strong>如果两个不可变类型的变量的值相同，这两个变量指向同一块内存地址，本质上是一个对象（即引用计数）；如果两个可变类型的变量的值相同，这两个变量指向不同的地址，本质上是两个对象。</strong></p><p>对于不可变数据类型，对应变量的值发生变化时，原内存中的值不变，而是新开辟一块内存，让变量指向新的内存地址；对于可变类型，变量的值发生变化时没有开辟新的内存空间。</p><h2 id="类的成员"><a href="#类的成员" class="headerlink" title="类的成员"></a>类的成员</h2><p>类的成员包括属性和方法两大类，其中属性可以分为实例属性和类属性，方法可以分为实例方法、类方法和静态方法等。下面将对这些属性和方法以及访问权限进行介绍。</p><h3 id="1-实例属性和实例方法"><a href="#1-实例属性和实例方法" class="headerlink" title="1. 实例属性和实例方法"></a>1. 实例属性和实例方法</h3><p>实例属性属于类的对象，需要在__init__方法中使用”<code>self.属性名 = 值</code>“进行定义，通过”<code>对象名.属性名</code>“调用。</p><p>实例方法即与类的对象相关的方法，要求第一个参数必须为self，即调用该方法的对象的引用，通过”<code>对象名.方法名</code>“调用。</p><p>示例如下：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:<br>    <span class="hljs-comment"># 实例方法say_hello</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">say_hello</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):<br>        print(<span class="hljs-string">&quot;Hello world!&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span>, input_name</span>):<br>        <span class="hljs-comment"># 实例属性name</span><br>        <span class="hljs-variable language_">self</span>.name = input_name<br></code></pre></td></tr></table></figure><p>注意：每个对象具有独立的内存空间，<strong>只保存各自的实例属性，不保存实例方法</strong>。<strong>实例方法在内存中只有一份</strong>，调用时需要把对象的引用传入方法内部。</p><h3 id="2-类属性和类方法"><a href="#2-类属性和类方法" class="headerlink" title="2. 类属性和类方法"></a>2. 类属性和类方法</h3><p>在Python中，类是一种特殊的对象，即<strong>类对象</strong>。在程序运行时，一个类可以创建多个实例，但是<strong>类对象在内存中只有一个</strong>。</p><p>类属性是类对象本身的属性，属于整个类，而不是某一特定实例，所有实例之间共享一个副本。与实例属性不同，类属性直接在类中定义即可，不需要在__init__函数中进行定义。</p><p>类方法是类对象本身的方法，需要使用修饰器@<strong>classmethod</strong>来标识。定义类方法时，第一个参数必须是<strong>cls</strong>（调用时不需要传递该参数）。在类方法内部，可以通过<code>cls.类属性</code>或者<code>cls.类方法</code>分别直接访问类的属性或调用其他的类方法。在类方法中访问实例属性会导致错误。</p><p>通过<code>类名.类属性</code>或者<code>类名.类方法</code>的形式可以访问类属性或者调用类方法。也可以通过对象访问类属性或者调用类方法，即<code>对象名.类属性</code>或者<code>对象名.类方法</code>。</p><p>示例如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Game:<br>    # 类属性 <br>    top_score = <span class="hljs-number">0</span><br><br>    def <span class="hljs-constructor">__init__(<span class="hljs-params">self</span>, <span class="hljs-params">name</span>)</span>:<br>        self.name = name<br><br>    # 类方法<br>    @classmethod<br>    def show<span class="hljs-constructor">_top_score(<span class="hljs-params">cls</span>)</span>:<br>        print(<span class="hljs-string">&quot;当前最高分为%d&quot;</span> % cls.top_score)<br><br>    def start<span class="hljs-constructor">_game(<span class="hljs-params">self</span>, <span class="hljs-params">score</span>)</span>:<br>        print(<span class="hljs-string">&quot;%s开始游戏&quot;</span> % self.name)<br>        <span class="hljs-keyword">if</span> <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Game</span>.</span></span>top_score &lt; score:<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Game</span>.</span></span>top_score = score<br><br>gamer1 = <span class="hljs-constructor">Game(<span class="hljs-string">&quot;小明&quot;</span>)</span><br>gamer1.start<span class="hljs-constructor">_game(150)</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Game</span>.</span></span>show<span class="hljs-constructor">_top_score()</span><br><br>gamer2 = <span class="hljs-constructor">Game(<span class="hljs-string">&quot;小华&quot;</span>)</span><br>gamer2.start<span class="hljs-constructor">_game(200)</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Game</span>.</span></span>show<span class="hljs-constructor">_top_score()</span><br></code></pre></td></tr></table></figure><p>结果为：小明开始游戏 当前最高分为150 小华开始游戏 当前最高分为200</p><h3 id="3-静态方法"><a href="#3-静态方法" class="headerlink" title="3. 静态方法"></a>3. 静态方法</h3><p>静态方法使用修饰器@<strong>staticmethod</strong>来标识，与类、类的对象无关，可以看作是类中定义的普通函数。通过<code>类名.静态方法名</code>调用，不需要创建对象。</p><p>示例如下：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tool</span>:<br>    count = <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span>, name</span>):<br>        <span class="hljs-variable language_">self</span>.name = name<br>        <span class="hljs-title class_">Tool</span>.count += <span class="hljs-number">1</span><br><br>    <span class="hljs-comment"># 静态方法</span><br>    <span class="hljs-variable">@staticmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">use_tool</span>():<br>        print(<span class="hljs-title class_">Tool</span>.count)<br><br>tool1 = <span class="hljs-title class_">Tool</span>(<span class="hljs-string">&quot;剪刀&quot;</span>)<br>tool2 = <span class="hljs-title class_">Tool</span>(<span class="hljs-string">&quot;锤头&quot;</span>)<br>tool3 = <span class="hljs-title class_">Tool</span>(<span class="hljs-string">&quot;钳子&quot;</span>)<br><span class="hljs-title class_">Tool</span>.use_tool()<br></code></pre></td></tr></table></figure><p>结果为：3</p><h3 id="4-访问权限"><a href="#4-访问权限" class="headerlink" title="4. 访问权限"></a>4. 访问权限</h3><p>与C++、Java等语言相比，Python对于类的成员没有严格的访问控制限制。为了避免命名冲突、保护类的内部数据和方法，可以将一些重要的数据或方法定义私有属性或私有方法。</p><p>在定义私有属性或私有方法时，需要在属性名或方法名前增加两个下划线，例如”__hello()”、”__name”等。</p><p>但Python目前的私有机制其实是伪私有，在类外部还是可以通过<code>对象名._类名__私有属性</code>或者<code>对象名._类名__私有方法</code>进行访问。</p><p>示例如下：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Hello</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">say_hello</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):<br>        print(<span class="hljs-variable language_">self</span>.__name)<br><br>    <span class="hljs-keyword">def</span>  <span class="hljs-title function_">__init__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span>, name</span>):<br>        <span class="hljs-variable language_">self</span>.__name = name<br><br>hello_python = <span class="hljs-title class_">Hello</span>(<span class="hljs-string">&quot;xiaoli&quot;</span>)<br>hello_python.say_hello()<br>print(hello_python._Hello__name)<br></code></pre></td></tr></table></figure><p>结果为：xiaoli xiaoli</p><h2 id="内置方法"><a href="#内置方法" class="headerlink" title="内置方法"></a>内置方法</h2><ol><li><strong>init</strong></li></ol><p>__init__方法是类的<strong>构造方法</strong>，<strong>在创建对象时会自动调用</strong>，用于初始化对象的属性或者执行一些初始化操作。在__init__方法内部可以定义<strong>实例属性</strong>（即对象属性），并通过参数为这些属性赋初值，因此在创建对象时需要提供相应的参数。示例如下：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span>, cat_name</span>):<br>        <span class="hljs-variable language_">self</span>.name = cat_name<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):<br>        print(<span class="hljs-string">&quot;吃东西&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">drink</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):<br>        print(<span class="hljs-string">&quot;喝水&quot;</span>)<br><br>cat = <span class="hljs-title class_">Cat</span>(<span class="hljs-string">&quot;xiaomei&quot;</span>)<br>cat.eat()       <br>cat.drink()     <br>print(cat.name) <br></code></pre></td></tr></table></figure><p>结果为：吃东西 喝水 xiaomei</p><p>注意：实例属性只能在__init__方法中定义，不能在其他成员方法中定义。</p><ol start="2"><li><strong>del</strong></li></ol><p>__del__方法是一个特殊方法，用于在对象销毁前执行一些清理工作，比如关闭文件、释放资源等。在Python中，对象的销毁是通过垃圾回收机制实现的，__del__方法<strong>在对象被销毁时自动调用</strong>。</p><p>如果通过<strong>del</strong>关键字删除对象，则对象会被立刻销毁；如果没有，则在当前函数执行结束时销毁对象。示例如下：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span>, cat_name</span>):<br>        <span class="hljs-variable language_">self</span>.name = cat_name<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__del__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):<br>        print(<span class="hljs-string">&quot;销毁对象%s&quot;</span> % <span class="hljs-variable language_">self</span>.name)<br><br>cat1 = <span class="hljs-title class_">Cat</span>(<span class="hljs-string">&quot;xiaomei&quot;</span>)<br>del cat1<br>print(<span class="hljs-string">&quot;hello&quot;</span>)<br></code></pre></td></tr></table></figure><p>结果为：销毁对象xiaomei hello</p><ol start="3"><li><strong>str</strong></li></ol><p>__str__方法是Python中的一个特殊方法，用来定义一个对象的字符串表示形式，返回值为一个字符串。</p><p>当使用print函数输出对象变量时，默认会输出对象的类以及对象在内存中的地址。如果类中定义了__str__方法，则默认输出__str__方法的返回值。代码如下：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span>, cat_name</span>):<br>        <span class="hljs-variable language_">self</span>.name = cat_name<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.name<br><br>cat1 = <span class="hljs-title class_">Cat</span>(<span class="hljs-string">&quot;xiaomei&quot;</span>)<br>print(cat1)<br></code></pre></td></tr></table></figure><p>结果为：xiaomei</p><ol start="4"><li><strong>new</strong></li></ol><p>__new__是由<strong>object基类</strong>提供的内置<strong>静态方法</strong>，用于创建类实例。使用<code>类名()</code>创建对象时，Python解释器会调用__new__方法<strong>为对象分配空间，并返回对象的引用</strong>。Python解释器获得对象的引用后，将该引用作为第一个参数传递给__init__方法。</p><p>参考文章:</p><ol><li><a href="https://zhuanlan.zhihu.com/p/331732504?ivk_sa=1024320u&utm_id=0">彻底理解Python中对象、对象与变量引用的关系</a></li><li><a href="https://blog.csdn.net/cnds123/article/details/130898914">Python类的成员介绍</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>二分查找</title>
    <link href="/posts/42877/"/>
    <url>/posts/42877/</url>
    
    <content type="html"><![CDATA[<h2 id="二分查找概述"><a href="#二分查找概述" class="headerlink" title="二分查找概述"></a>二分查找概述</h2><p>二分查找（Binary Search，简称<strong>BS</strong>），又称<strong>折半查找</strong> ，是一种效率很高的查找方法。</p><p>算法要求：<br>1.线性表必须采用<strong>顺序存储</strong>结构，不能为链式结构<br>2.元素已经排过序(<strong>有序</strong>)</p><p>算法原理：<br>每次取搜索区间[low，high]中间位置mid的值进行判断，进而使搜索区间减半，即将原区间划分为[low,mid-1]和[mid+1,high]两个区间。重复这一过程，查找结束，获取目标值的索引或者未找到。</p><p>时间复杂度：<br>每一次以中间元素作为根节点，将中间元素的左侧区间和右侧区间分别作为左子树和右子树，依次执行可以将整个区间转化为一棵<strong>二叉搜索树</strong>。该搜索树的高度为logn，因此时间复杂度为<strong>O（logn）</strong>。</p><p>对于二分查找的理解，Kmp算法的发明者Knuth曾经说过：思路很简单，细节是魔鬼。BS具有许多实现形式（循环、递归等），而这些形式在细节上有所不同，比如搜索区间（左开右闭、左闭右开、左闭右闭等）、循环条件、区间更新操作等。</p><h2 id="标准BS"><a href="#标准BS" class="headerlink" title="标准BS"></a>标准BS</h2><p>搜索区间：[low,high]（<strong>左闭右闭</strong>）（下面以升序为例）<br>思路：每次比较target与当前中间位置元素nums[mid]的大小。如果两者相等，则找到目标元素的索引；如果target比较大，则说明target在mid右侧；如果target比较小，则说明target在mid左侧。经过上述过程，<strong>low左侧的元素都比target小，high右侧的元素比target大</strong>，当low&#x3D;&#x3D;high+1时，说明未找到元素，终止循环，见下图。</p><p><img src="/../images/BS/%E6%A0%87%E5%87%86BS.png" alt="标准BS"></p><p>代码：</p><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs stan"><span class="hljs-type">int</span> binarySearch(<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt; nums, <span class="hljs-type">int</span> <span class="hljs-built_in">target</span>)&#123;<br>    <span class="hljs-type">int</span> low = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> high = nums.<span class="hljs-built_in">size</span>()-<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(low &lt;= high)&#123;<br>        <span class="hljs-type">int</span> mid = (low+high)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(nums[mid] == <span class="hljs-built_in">target</span>) <span class="hljs-keyword">return</span> mid;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &lt; <span class="hljs-built_in">target</span>) low = mid+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &gt; <span class="hljs-built_in">target</span>) high = mid-<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">//表示未找到</span><br>&#125;<br></code></pre></td></tr></table></figure><p>作用：查找某一个数<br>注意：</p><ol><li>由于mid本身已经判断过，无需进行下一步的搜索，因此区间更新操作为low&#x3D;mid+1或者high&#x3D;mid-1（而不是low&#x3D;mid或者high&#x3D;mid）。</li><li>循环判断条件为low&lt;&#x3D;high，对应的终止条件为low&#x3D;&#x3D;high+1，此时搜索区间为空。而如果改为low&lt;high，则终止条件为low&#x3D;&#x3D;high，当前索引low没有被搜索。</li><li><strong>溢出问题</strong>：在low和high的值较大的情况下，计算mid时会产生整数溢出。因此可以将mid的计算形式改为<code>mid=low+(high-low)/2</code></li></ol><h2 id="边界问题"><a href="#边界问题" class="headerlink" title="边界问题"></a>边界问题</h2><p>对于一些获取左右边界的问题，例如对于序列seq&#x3D;[1，2，3，3，3，4，5]，target&#x3D;3，如果想要获取第一个等于target的元素的下标，标准BS则无法解决。下面以查找左边界为例。</p><p>搜索区间：[low,high]（左闭右闭）<br>思路：比较target与nums[mid]的大小，记第一个等于target的元素为elem。如果两者相等，则说明elem在mid左侧或者等于mid。如果target比较大，则说明elem在mid右侧；如果target比较小，则elem一定在mid左侧。<strong>low左侧的元素都比target小，high右侧的元素都大于等于target</strong>，当low&#x3D;&#x3D;high+1时，终止循环，见下图。</p><p><img src="/../images/BS/%E5%B7%A6%E8%BE%B9%E7%95%8CBS.png" alt="左边界BS"></p><p>代码：</p><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs stan"><span class="hljs-type">int</span> binarySearch_lowerBound(<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt; nums, <span class="hljs-type">int</span> <span class="hljs-built_in">target</span>)&#123;<br>    <span class="hljs-type">int</span> low = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> high = nums.<span class="hljs-built_in">size</span>()-<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(low &lt;= high)&#123;<br>        <span class="hljs-type">int</span> mid = (low+high)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(nums[mid] == <span class="hljs-built_in">target</span>) high = mid-<span class="hljs-number">1</span>; <br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &lt; <span class="hljs-built_in">target</span>) low = mid+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &gt; <span class="hljs-built_in">target</span>) high = mid-<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(low == nums.<span class="hljs-built_in">size</span>() || nums[low] != <span class="hljs-built_in">target</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">//未找到</span><br>    <span class="hljs-keyword">return</span> low; <span class="hljs-comment">//找到左边界</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意：<br>1.与标准BS不同之处在于：当nums[mid]&#x3D;&#x3D;target时，elem可能在mid左侧，因此high&#x3D;mid-1，而不能返回索引。<br>2.循环终止条件只有一个，即low&#x3D;&#x3D;high+1，无论查找成功或者失败，只要满足这一条件时均会终止循环，因此需要判断是否查找成功。如果<strong>当前low对应的元素不等于target或者low等于数组长度</strong>（见下图），则查找失败；反之查找成功，此时low对应的元素即为elem。</p><p><img src="/../images/BS/%E5%B7%A6%E8%BE%B9%E7%95%8CBS-low%E8%B6%8A%E7%95%8C.png" alt="low越界"></p><p>附查找右边界的代码：</p><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs stan"><span class="hljs-type">int</span> binarySearch_upperBound(<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt; nums, <span class="hljs-type">int</span> <span class="hljs-built_in">target</span>)&#123;<br>    <span class="hljs-type">int</span> low = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> high = nums.<span class="hljs-built_in">size</span>()-<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(low &lt;= high)&#123;<br>        <span class="hljs-type">int</span> mid = (low+high)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(nums[mid] == <span class="hljs-built_in">target</span>) low = mid+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &lt; <span class="hljs-built_in">target</span>) low = mid+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &gt; <span class="hljs-built_in">target</span>) high = mid-<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(high&lt;<span class="hljs-number">0</span> || nums[high] != <span class="hljs-built_in">target</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">//未找到</span><br>    <span class="hljs-keyword">return</span> high; <span class="hljs-comment">//找到右边界</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../images/BS/%E5%8F%B3%E8%BE%B9%E7%95%8CBS.png" alt="右边界BS"></p><p><strong>参考文章</strong>：</p><ol><li><a href="https://www.cnblogs.com/kyoner/p/11080078.html">详解二分查找算法</a></li><li><a href="https://blog.csdn.net/qjyws/article/details/126416671">算法刷题：二分查找及对应左边界和右边界的寻找整理</a></li><li><a href="https://zhuanlan.zhihu.com/p/569929092">二分查找</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python函数进阶</title>
    <link href="/posts/53362/"/>
    <url>/posts/53362/</url>
    
    <content type="html"><![CDATA[<h2 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h2><p>Python函数的参数传递方式为<strong>引用传递</strong>，即让形参变量指向实参变量所绑定的对象。引用即变量到对象的指针。</p><p>函数<strong>id</strong>()可以返回对象的id标识，每个对象由唯一的id标识。</p><p>注意：</p><ol><li>如果实参是可变类型，在函数内部通过形参调用<strong>方法</strong>改变数据的内容，会修改实参的值。</li><li>如果实参是可变类型，在函数体内部通过形参执行<strong>赋值语句</strong>，不会修改实参。使用赋值语句只会让形参指向一个新创建的对象，并不会对实参产生影响。</li></ol><p><img src="/../images/Python/%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6-%E9%80%9A%E8%BF%87%E5%BD%A2%E5%8F%82%E6%89%A7%E8%A1%8C%E8%B5%8B%E5%80%BC%E8%AF%AD%E5%8F%A5.png" alt="执行赋值语句"></p><ol start="3"><li><strong>如果实参是不可变类型，在函数体内修改不会影响实参的值。</strong></li></ol><p>变量的声明和赋值本质：把一个变量绑定到某个内存单元（即对象）。</p><h3 id="缺省参数"><a href="#缺省参数" class="headerlink" title="缺省参数"></a>缺省参数</h3><p>具有默认值的参数为缺省参数（也称为可变参数）。<br>注意：必须保证带有默认值的缺省参数在<strong>参数列表末尾</strong>，否则会报错。</p><p><img src="/../images/Python/%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6-%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0%E4%BD%8D%E7%BD%AE.png" alt="缺省参数位置"></p><h3 id="多值参数"><a href="#多值参数" class="headerlink" title="多值参数"></a>多值参数</h3><p>当函数的参数数目不确定时可以使用多值参数。参数名前增加<strong>一个星号可以接收元组，两个星号可以接收字典</strong>。命名时通常采用以下方式：</p><blockquote><p>*args 存放元组参数 （args为arguments的缩写）<br>**kwargs 存放字典参数 （kw为keyword的缩写）</p></blockquote><p>实例：<br><img src="/../images/Python/%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6-%E5%A4%9A%E5%80%BC%E5%8F%82%E6%95%B0.png" alt="多值参数"></p><p><strong>拆包语法</strong><br>如果需要将一个元组变量直接传递给args，则在该变量前增加一个星号；<br>如果需要将一个字典变量直接传递给kwargs，则在字典变量前增加两个星号。</p><p><img src="/../images/Python/%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6-%E6%8B%86%E5%8C%85%E8%AF%AD%E6%B3%95.png" alt="拆包语法"></p><p>注意：采用这种方式传递的字典变量的键必须为str类型。</p><h3 id="命名参数"><a href="#命名参数" class="headerlink" title="命名参数"></a>命名参数</h3><p>Python在函数调用时默认按照位置顺序传递形参。而按照名称指定传入的参数称为命名参数（也称关键字参数）。采用这种方式<strong>传递的参数与顺序无关</strong>。如果存在多个缺省参数时，可以选择特定的参数进行传递。</p><p><img src="/../images/Python/%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6-%E5%91%BD%E5%90%8D%E5%8F%82%E6%95%B0.png" alt="命名参数"></p><h2 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h2><p>Python中函数的返回值采用<strong>引用传递</strong>方式。</p><p><img src="/../images/Python/%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6-%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92.png" alt="返回值的引用传递"></p><p>函数使用<strong>元组</strong>可以返回多个值，同时可以使用多个变量接收函数的多个返回值。</p><p><img src="/../images/Python/%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6-%E5%A4%9A%E4%B8%AA%E8%BF%94%E5%9B%9E%E5%80%BC.png" alt="多个返回值"></p><h2 id="变量的作用域和生存期"><a href="#变量的作用域和生存期" class="headerlink" title="变量的作用域和生存期"></a>变量的作用域和生存期</h2><p><strong>全局变量</strong>：在函数和类之外声明的变量。<br><strong>局部变量</strong>：在函数体中声明的变量。</p><p>注意：</p><ol><li>全局变量可以被不同的模块和函数访问，可能会导致程序错误，因此应尽量避免使用全局变量。</li><li>局部变量在函数执行时才会被创建。</li><li>如果在函数内部定义一个与全局变量同名的变量，该变量为局部变量。Python中不允许直接修改全局变量的值，如果需要修改则在函数内部使用<strong>global</strong>关键字。</li></ol><p><img src="/../images/Python/%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6-%E4%BF%AE%E6%94%B9%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F.png" alt="使用global修改全局变量"></p><p>变量的生命周期（生存期）：变量从<strong>被创建到被系统回收</strong>的过程</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python基础-数据容器(3)</title>
    <link href="/posts/54928/"/>
    <url>/posts/54928/</url>
    
    <content type="html"><![CDATA[<h3 id="公共方法"><a href="#公共方法" class="headerlink" title="公共方法"></a>公共方法</h3><p>在常用五种数据容器中，<strong>列表、元组、字符串</strong>为序列类型，集合和字典为无序类型。公共方法如下图所示：</p><p><img src="/../images/Python/%E6%95%B0%E6%8D%AE%E5%AE%B9%E5%99%A8(3)-%E5%85%AC%E5%85%B1%E6%96%B9%E6%B3%95.png" alt="公共方法"></p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p><img src="/../images/Python/%E6%95%B0%E6%8D%AE%E5%AE%B9%E5%99%A8(3)-%E8%BF%90%E7%AE%97%E7%AC%A6.png" alt="运算符"></p><h3 id="迭代遍历"><a href="#迭代遍历" class="headerlink" title="迭代遍历"></a>迭代遍历</h3><p>Python包括以下可迭代对象:<strong>序列类型、集合、字典、迭代器对象</strong>等。通用的遍历语句如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">for</span> 变量 <span class="hljs-keyword">in</span> 可迭代对象集合：<br>循环体代码<br><span class="hljs-keyword">else</span>:<br>如果循环体内部使用<span class="hljs-keyword">break</span>退出循环，这一部分代码就不会被执行<br></code></pre></td></tr></table></figure><p>注：关键字<strong>Pass</strong>一般用于占位语句，可以保证程序的结构正确。程序运行时，pass不会执行任何操作。</p><h3 id="序列的切片"><a href="#序列的切片" class="headerlink" title="序列的切片"></a>序列的切片</h3><p>切片操作可以截取序列的一部分，基本形式如下：</p><p><code>s[开始下标i: 结束下标j: 步长l]</code></p><p>截取部分的范围采用“<strong>左开右闭</strong>”原则。切片采用两种索引方式，分别为正索引和负索引。<br>正索引：从序列首部到末尾依次为0、1、2…<br>负索引：从序列末尾到首部依次为-1、-2、-3…</p><p>如果省略步长则默认步长为1。<strong>步长的正负决定截取的方向</strong>，如果步长为正数表示从左往右截取，反之为负数则表示从右往左截取。<br>开始下标和结束下标均可以缺省，默认值为<strong>序列在当前截取方向上的起点和终点</strong>。例如对于列表a &#x3D; [0,1,2]，如果步长为负，则开始下标的缺省值为2，结束下标为0。</p><p>以列表为例：<br><img src="/../images/Python/%E6%95%B0%E6%8D%AE%E5%AE%B9%E5%99%A8(3)-%E5%88%87%E7%89%87.png" alt="序列的切片"></p><p>注意:在切片中，<strong>如果索引超出有效范围不会报错</strong>，而是会进行<strong>截断</strong>，即超出部分全部视为空值，最终获取时忽略这一部分空值。</p><p>应用:无需遍历即可获取序列的<strong>逆序</strong></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python基础-数据容器(2)</title>
    <link href="/posts/18065/"/>
    <url>/posts/18065/</url>
    
    <content type="html"><![CDATA[<h2 id="字符串-str"><a href="#字符串-str" class="headerlink" title="字符串 str"></a>字符串 str</h2><h3 id="1-常用方法总结"><a href="#1-常用方法总结" class="headerlink" title="1.常用方法总结"></a>1.常用方法总结</h3><p>其中s1、s2均代表字符串</p><ol><li><p>统计与查找</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-built_in">s1</span>.count(<span class="hljs-built_in">s2</span>) <span class="hljs-comment"># 统计子字符串s2在s1中出现的次数</span><br><br><span class="hljs-built_in">s1</span>.index(<span class="hljs-built_in">s2</span>) <span class="hljs-comment"># 获取子字符串s2在s1中的起始下标</span><br><span class="hljs-built_in">s1</span>.find(<span class="hljs-built_in">s2</span>) <span class="hljs-comment"># 查找子串s2并返回起始下标</span><br><span class="hljs-comment"># index与find区别在于：如果子串不存在，find方法返回-1，而index方法会报错</span><br></code></pre></td></tr></table></figure></li><li><p>判断</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta"># 返回值均为布尔型</span><br>s.isdecimal() <span class="hljs-meta"># 判断是否为数字，不能判断小数</span><br>s.isdigit() <span class="hljs-meta"># 判断是否为数字，支持判断单字节数字，不能判断小数</span><br>s.islower() <span class="hljs-meta"># 判断字母是否全为小写</span><br>s.isupper() <span class="hljs-meta"># 判断字母是否全为大写</span><br>s.isspace() <span class="hljs-meta"># 判断是否为空格</span><br></code></pre></td></tr></table></figure></li><li><p>替换</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-built_in">s2</span> = <span class="hljs-built_in">s1</span>.replace(<span class="hljs-keyword">sub1,sub2) </span><span class="hljs-comment"># 将s1中的所有子串sub1替换为sub2，返回一个新字符串</span><br><span class="hljs-built_in">s2</span> = <span class="hljs-built_in">s1</span>.upper()  <span class="hljs-comment"># 将s1所有字母转为大写，返回一个字符串</span><br><span class="hljs-built_in">s2</span> = <span class="hljs-built_in">s1</span>.lower()  <span class="hljs-comment"># 将s1所有字母转为小写，返回一个字符串</span><br></code></pre></td></tr></table></figure></li><li><p>分割与拼接</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">s_list</span> = s.split()   <span class="hljs-comment"># 分割字符串，返回一个列表。</span><br><span class="hljs-comment"># 如果参数为空，则默认以空白字符为分隔符进行拆分；</span><br><span class="hljs-comment"># 如果不为空，则按照该字符进行分割，结果中不包括该字符。</span><br><br><span class="hljs-attr">s2</span> = s1.join(seq) <span class="hljs-comment"># 拼接字符串，以s1作为连接符，seq为字符或字符串序列。</span><br><span class="hljs-attr">s2</span> = s1 * num    <span class="hljs-comment"># 将s1拼接num次</span><br></code></pre></td></tr></table></figure></li></ol><p>实例：<br><img src="/../images/Python/%E6%95%B0%E6%8D%AE%E5%AE%B9%E5%99%A8(2)-split.png" alt="字符串分割"><br><img src="/../images/Python/%E6%95%B0%E6%8D%AE%E5%AE%B9%E5%99%A8(2)-join.png" alt="字符串拼接"></p><ol start="5"><li>文本对齐<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># 使用指定字符（默认为空格）将内容填充至长度length，返回一个新字符串</span><br><span class="hljs-attr">s2</span> = s1.center(length)  <span class="hljs-comment"># 居中对齐</span><br><span class="hljs-attr">s2</span> = s1.ljust(length)   <span class="hljs-comment"># 左对齐</span><br><span class="hljs-attr">s2</span> = s1.rjust(length)   <span class="hljs-comment"># 右对齐</span><br></code></pre></td></tr></table></figure></li></ol><p>实例：<br><img src="/../images/Python/%E6%95%B0%E6%8D%AE%E5%AE%B9%E5%99%A8(2)-just.png" alt="文本对齐"></p><ol start="6"><li>去除空白字符<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">s2</span> = s1.strip()   <span class="hljs-comment"># 去除左右两侧的空白字符（\t\n\r等）</span><br><span class="hljs-attr">s2</span> = s1.lstrip()  <span class="hljs-comment"># 去除左侧的空白字符</span><br><span class="hljs-attr">s2</span> = s1.rstrip()  <span class="hljs-comment"># 去除右侧的空白字符</span><br></code></pre></td></tr></table></figure></li></ol><p>实例：<br><img src="/../images/Python/%E6%95%B0%E6%8D%AE%E5%AE%B9%E5%99%A8(2)-strip.png" alt="去除空白字符"></p><h3 id="2-字符串的格式化"><a href="#2-字符串的格式化" class="headerlink" title="2.字符串的格式化"></a>2.字符串的格式化</h3><p>字符串的格式化是一种将数据转化为特定格式的字符串的方法。在Python中主要有以下几种实现形式：</p><ol><li>%形式</li></ol><p><code>格式化字符串 % (值1,值2,...)</code></p><p>在格式化字符串内部，%操作符起占位作用，%之后的部分是需要格式化的内容，可以使用变量对这些内容进行替换。常见的几种格式化字符如下：<br><img src="/../images/Python/%E6%95%B0%E6%8D%AE%E5%AE%B9%E5%99%A8(2)-format_char.png" alt="格式化字符"></p><p>实例：<br><img src="/../images/Python/%E6%95%B0%E6%8D%AE%E5%AE%B9%E5%99%A8(2)-%E7%99%BE%E5%88%86%E5%8F%B7%E5%BD%A2%E5%BC%8F.png" alt="%形式"></p><ol start="2"><li>format形式</li></ol><p><code>格式化字符串.format(值1,值2,...)</code></p><p>在格式化字符串内部，{}为占位符，{}内部为需要格式化的内容。format函数中常见的格式化字符与%形式的基本一致，例如s代表字符串，d代表十进制整数，f代表浮点数。</p><p>注意：{}内部第一部分为索引或键，第二部分为格式符号（包括格式化字符等），两部分之间用冒号隔开。如果{}内部不写索引，默认从0开始递增排列。</p><p>实例：<br><img src="/../images/Python/%E6%95%B0%E6%8D%AE%E5%AE%B9%E5%99%A8(2)-format_format.png" alt="format形式"></p><p>与%形式相比，format函数能够可以实现文本对齐、百分制等更为复杂的功能。</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python基础-数据容器(1)</title>
    <link href="/posts/46737/"/>
    <url>/posts/46737/</url>
    
    <content type="html"><![CDATA[<h2 id="1-列表-list"><a href="#1-列表-list" class="headerlink" title="1.列表 list"></a>1.列表 list</h2><p>列表（即数组）索引值从0开始，一般情况下默认列表中的所有数据的类型一致。</p><p>常用方法如下：<br><img src="/../images/Python/%E6%95%B0%E6%8D%AE%E5%AE%B9%E5%99%A8(1)-list.png" alt="列表常用方法总结"></p><p>注意：</p><ol><li>clear与del的区别<br>clear会清除列表中所有元素，但内存并未释放，仍然可以通过变量名访问；<strong>del关键字会将变量从内存中删除</strong>，此时不能继续使用变量名，否则会报错。如果仅删除某一个索引对应的元素，则后续元素均向前移动一位，索引值均减1。区别见下图：</li></ol><p><img src="/../images/Python/%E6%95%B0%E6%8D%AE%E5%AE%B9%E5%99%A8(1)-del.png" alt="del删除列表"></p><ol start="2"><li>append与extend的区别<br>extend用于合并列表，将需要插入的列表的元素加入原列表，参数为<strong>可迭代对象</strong>；append直接将整个对象当作一个元素加入原列表末尾，参数为任意对象。其区别见下图：</li></ol><p><img src="/../images/Python/%E6%95%B0%E6%8D%AE%E5%AE%B9%E5%99%A8(1)-append.png" alt="append与extend"></p><h2 id="2-元组-tuple"><a href="#2-元组-tuple" class="headerlink" title="2.元组 tuple"></a>2.元组 tuple</h2><p>元组是由多个元素组成的序列，<strong>元组的元素不能被修改</strong></p><p><strong>元组只包含一个元素时需要在元素后面添加逗号</strong></p><p>常用方法：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-meta"># t代表元组</span><br><br>t.<span class="hljs-keyword">count</span>(k) <span class="hljs-meta"># 统计数据k出现的次数</span><br><br>t.<span class="hljs-keyword">index</span>(k) <span class="hljs-meta"># 查找数据k，返回数据k第一次匹配时的索引位置，如果对象不在元组中会产生异常</span><br><br>len(t) <span class="hljs-meta"># 统计元组的长度</span><br></code></pre></td></tr></table></figure><p>应用：（1）函数的参数和返回值（2）格式化字符串（3）将列表转化为元组，保证数据安全</p><p>元组和列表的转换<br>元组-&gt;列表：列表&#x3D;list（元组）  列表-&gt;元组：元组&#x3D;tuple（列表）</p><p>面试题：交换两个数字a&#x3D;6,b&#x3D;100,不能使用其他变量<br>解法一：a&#x3D;a+b b&#x3D;a-b a&#x3D;a-b<br>解法二：使用元组 a,b&#x3D;(b,a)</p><h2 id="3-集合"><a href="#3-集合" class="headerlink" title="3.集合"></a>3.集合</h2><p>Python中的集合与数学上的集合一致。集合是<strong>无序</strong>对象的聚集，并且集合中的元素<strong>不重复</strong>。存储的元素为字符串、数值类型或者元组等<strong>不可变类型</strong>。集合的内部实现基于<strong>哈希表</strong>。集合之间可以进行并集、交集、差集等运算。</p><p>集合分为可变集合set和不可变集合frozenset。下面主要介绍可变集合的常用方法(其中s、s1、s2均代表集合名)：</p><ol><li><p>添加</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">s.<span class="hljs-keyword">add</span>(elem)  <span class="hljs-meta"># 向集合添加一个元素elem，如果该元素已存在则不产生效果</span><br>s.update(iter)  <span class="hljs-meta"># 将可迭代对象iter的元素添加到集合中   </span><br></code></pre></td></tr></table></figure></li><li><p>删除</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs maxima">s.<span class="hljs-built_in">remove</span>(<span class="hljs-built_in">elem</span>) # 删除指定元素<span class="hljs-built_in">elem</span>，如果不存在会报错<br>s.discard(<span class="hljs-built_in">elem</span>) # 删除指定元素<span class="hljs-built_in">elem</span>，如果不存在则忽略<br>s.clear()   # 清空集合<br></code></pre></td></tr></table></figure></li><li><p>集合运算</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">s1</span> &amp; s2 <span class="hljs-comment"># 交集</span><br>s1 | s2 <span class="hljs-comment"># 并集</span><br>s1 - s2 <span class="hljs-comment"># 差集</span><br></code></pre></td></tr></table></figure><p>注意：如果要创建一个空集合，则必须用set函数创建，不能使用{ }创建（否则会创建一个空字典）</p></li></ol><h2 id="4-字典-dict"><a href="#4-字典-dict" class="headerlink" title="4.字典 dict"></a>4.字典 dict</h2><p>字典是<strong>存储无序</strong>的对象集合（列表存储的是有序对象），是键和值的<strong>哈希映射</strong>关系。它的实现同样基于<strong>哈希表</strong>。</p><p>特点：<br>（1）使用键值对存储数据，键值对之间使用逗号分隔，键和值之间使用冒号分隔<br>（2）<strong>键必须唯一</strong><br>（3）键必须是<strong>不可变类型</strong>，值可以取任意数据类型</p><p>字典的常用方法如下(其中d代表字典名,key代表键，value代表值)：</p><ol><li><p>添加</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs q">d[<span class="hljs-built_in">key</span>]=<span class="hljs-built_in">value</span>   # 如果<span class="hljs-built_in">key</span>存在，修改已存在的键值对；如果<span class="hljs-built_in">key</span>不存在，新增键值对<br><br>d1.<span class="hljs-keyword">update</span>(d2) <br># 将字典d2合并到字典d1中。如果字典d1和字典d2存在相同的键，则将对原键值对进行覆盖<br></code></pre></td></tr></table></figure></li><li><p>查看</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">keys</span> = d.keys()      <span class="hljs-comment"># 获取所有键key</span><br><span class="hljs-attr">values</span> = d.values()  <span class="hljs-comment"># 获取所有值value</span><br><span class="hljs-attr">items</span> = d.items()    <span class="hljs-comment"># 获取字典中的每一个元素</span><br></code></pre></td></tr></table></figure><p>这三种方法的返回值均为<strong>可迭代的视图对象</strong>，它们并不具备列表的功能，即无法通过索引获取元素、无法修改、无法使用内置方法等，仅支持迭代遍历。可以通过list函数将这些对象转化为列表进行操作。</p></li></ol><p>实例：<br><img src="/../images/Python/%E6%95%B0%E6%8D%AE%E5%AE%B9%E5%99%A8(1)-keys.png" alt="视图对象"></p><ol start="3"><li><p>删除</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">del</span> d[<span class="hljs-built_in">key</span>]  # 删除键为<span class="hljs-built_in">key</span>对应的键值对<br><span class="hljs-built_in">del</span> d       # 删除整个字典，释放内存空间<br>d.<span class="hljs-built_in">pop</span>(<span class="hljs-built_in">key</span>)  # 如果键<span class="hljs-built_in">key</span>存在，返回并删除其值；如果指定的<span class="hljs-built_in">key</span>不存在，则会报错<br>d.clear()   # 清除字典中的元素<br></code></pre></td></tr></table></figure></li><li><p>迭代遍历</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> d:      <span class="hljs-meta"># k为每次遍历获得的键值对的key</span><br>    <span class="hljs-keyword">print</span>(k,d[k]) <br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python基础-基本语法</title>
    <link href="/posts/61427/"/>
    <url>/posts/61427/</url>
    
    <content type="html"><![CDATA[<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="1-数据类型与运算符"><a href="#1-数据类型与运算符" class="headerlink" title="1.数据类型与运算符"></a>1.数据类型与运算符</h3><blockquote><p>Python中变量不需要显式声明数据类型。程序运行时，Python解释器会根据赋值语句等号右侧的数据自动推导出变量保存数据的类型。</p></blockquote><p>Python内置数据类型可以分为数值数据类型和非数值数据类型。其中内置数值数据类型有4种：int、float、bool、complex（复数类型），非数值数据类型有str、tuple（元组）、list（列表）、dict（字典）等。</p><p>Python数据类型可分为可变类型和不可变类型两种。<br><strong>不可变类型</strong>：数据不允许被修改。包括数值数据类型（4种）、str、tuple等。<br><strong>可变类型</strong>：数据可以被修改。包括list、可变集合set、dict等。</p><p>Python中的运算符与C++基本一致，需要注意以下几个：</p><ol><li>与C++不同，Python中逻辑运算符为and、or、not</li><li>**表示乘方运算</li><li>&#x2F;表示浮点数除法，而&#x2F;&#x2F;表示<strong>除法取整</strong></li></ol><h3 id="2-标识符"><a href="#2-标识符" class="headerlink" title="2.标识符"></a>2.标识符</h3><p>Python标识符的命名规则：</p><ol><li>由<strong>字母、下划线和数字</strong>组成</li><li>不能由数字开头 </li><li>不能与关键字重名</li></ol><p>注：Python中的标识符是区分大小写的</p><p><strong>关键字</strong>即Python内部已经使用的标识符</p><p>Python命名规范：<br>（1）变量、函数、模块、包：<strong>单词的首字母采用小写字母，单词之间用下划线连接</strong>，例如：first_name<br>（2）类名：大驼峰，例如：MyHome<br>（3）常量名：所有字符全部大写，例如：LEFT</p><p>补充：在其他语言中，标识符的命名常采用<em>驼峰法</em></p><blockquote><p>大驼峰（又称<strong>Pascal命名法</strong>）：组成标识符的每个单词首字符都采用大写字母<br>小驼峰：第一个单词以小写字母开始，后续单词的首字母大写</p></blockquote><h3 id="3-程序结构"><a href="#3-程序结构" class="headerlink" title="3.程序结构"></a>3.程序结构</h3><ol><li>顺序结构</li><li>分支结构：if、else、elif（等价于C语言的else if）等</li><li>循环结构：for、while、break、continue等</li></ol><h3 id="4-变量"><a href="#4-变量" class="headerlink" title="4.变量"></a>4.变量</h3><p>程序中的数据保存在内存之中，Python并不像汇编语言和机器语言那样直接通过内存地址访问数据，而是通过赋值语局将变量<strong>绑定</strong>到相应的内存单元，之后通过变量来访问数据。</p><blockquote><p>如果<em>环境</em>将名字x映射到存储单元s，则称x被<em>绑定</em>到s。环境表示将名字映射到存储单元的函数。——陈意云，张昱《编译原理（第三版）》</p></blockquote><p><strong>Python变量被访问之前必须进行初始化，即赋值。</strong></p><h3 id="5-函数和模块"><a href="#5-函数和模块" class="headerlink" title="5.函数和模块"></a>5.函数和模块</h3><p>使用<strong>import</strong>关键字可以导入模块（包&#x2F;Python源文件）。生成随机数的代码如下：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-comment"># 随机生成一个[1，100]的整数</span><br>import <span class="hljs-built_in">random</span><br><span class="hljs-built_in">num</span> = <span class="hljs-built_in">random</span>.randint(<span class="hljs-number">1</span>,<span class="hljs-number">100</span>)                     <br></code></pre></td></tr></table></figure><p>补充：在导入模块时，Python解释器会在与模块文件同一目录的__pycache__子目录下生成.pvc文件。pyc文件是由Python解释器<strong>编译过的字节码文件</strong>。字节码是一种低级的、与平台无关的代码，可以被Python虚拟机直接执行，提高程序的执行速度。</p><p>Python解释源程序分为两个步骤：<br>（1）处理源代码，编译生成一个二进制字节码<br>（2）对字节码进行处理，生成CPU能够识别的机器码</p><p>函数定义使用<strong>def</strong>关键字，其中参数不包含类型。在使用其他文件或模块定义的函数时，需要先使用import关键字导入该文件。</p><h3 id="6-输入和输出函数"><a href="#6-输入和输出函数" class="headerlink" title="6.输入和输出函数"></a>6.输入和输出函数</h3><p><strong>input</strong>函数能够接收从键盘输入的数据，<strong>返回字符串类型</strong>。其中括号内的信息为提示信息，并不包含在返回值中。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">name</span> <span class="hljs-operator">=</span> input(<span class="hljs-string">&quot;请输入姓名：&quot;</span>)<br></code></pre></td></tr></table></figure><p><strong>print</strong>函数能够打印输出文本，并且可以实现格式化输出。print函数由参数end指定换行符，默认输出内容后在末尾自动换行，即end&#x3D;’\n’。</p><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs hsp"><span class="hljs-keyword">print</span>(<span class="hljs-string">&quot;我的名字是%s&quot;</span> % name)    <span class="hljs-meta">#输出格式化字符串</span><br><span class="hljs-keyword">print</span>(<span class="hljs-string">&quot;hello world&quot;</span>, <span class="hljs-keyword">end</span> = <span class="hljs-string">&quot;&quot;</span>)  <span class="hljs-meta"># 不换行</span><br></code></pre></td></tr></table></figure><p>补充：<br>常用的几种转义字符如下所示：</p><p><img src="/../images/Python/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6.png" alt="转义字符"></p><p>注：\t 能够使文本在垂直方向上保持对齐</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python基础-预备知识</title>
    <link href="/posts/32360/"/>
    <url>/posts/32360/</url>
    
    <content type="html"><![CDATA[<h2 id="Python简介"><a href="#Python简介" class="headerlink" title="Python简介"></a>Python简介</h2><p>Python是由<strong>吉多.范罗苏姆</strong>(Guido van Rossum)创造的一门独特的程序设计语言。Python是一门<strong>完全面向对象</strong>的语言,它遵循优雅、明确、简单的设计哲学。</p><p>Python语言具有简单易学、开源、面向对象等优点，但与C&#x2F;C++相比，它的运行速度较慢，同时这门语言对格式的要求极为严格。</p><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><h3 id="编译与解释"><a href="#编译与解释" class="headerlink" title="编译与解释"></a>编译与解释</h3><p>计算机无法直接执行使用高级语言编写的源程序，只能够识别执行低级的机器指令，因此需要一种翻译程序，将源程序转化为CPU能够执行的机器指令。翻译方式可以分为解释和编译两种，具体运行过程见下图。</p><p><img src="/../images/Python/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-compile.png" alt="编译与解释"></p><p><strong>编译</strong>是先将整个程序源代码翻译为等价的机器语言或者汇编语言格式的目标程序，之后再由CPU执行，例如C、C++等。<strong>解释</strong>是逐行翻译源程序，每翻译一句，CPU就执行一句，不产生目标代码，例如R、Python等。</p><p><strong>编译型语言的执行速度快，解释型语言跨平台性能好</strong>，而Java的跨平台是通过虚拟机实现的。</p><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>调试方法：在某一行设置一个断点，当程序执行到断点时暂时停止继续执行，之后通过单步调试继续向下执行。</p><p>程序断点原理：断点（breakpoint）的本质是一个<strong>中断信号</strong>，CPU执行至断点时产生中断，由调试器将程序挂起，此时程序并没有终止或者结束。</p><p>常用的调试器提供了多种单步调试方式：</p><ol><li>step into：进入子函数内部并继续单步执行</li><li>step over：不会进入子函数内部单步执行，而是把整个子函数当作一步执行</li><li>step out：将子函数中剩余部分执行完，返回上一级函数，与step into配合使用</li></ol><h3 id="Python程序排错"><a href="#Python程序排错" class="headerlink" title="Python程序排错"></a>Python程序排错</h3><ol><li>每行代码完成一个动作，因此不能把多条语句写在同一行。</li><li>缩进错误。（由于对格式的严格要求，Python语言也被称为“<strong>游标卡尺语言</strong>”）</li></ol><h3 id="Python执行方式"><a href="#Python执行方式" class="headerlink" title="Python执行方式"></a>Python执行方式</h3><ol><li>解释器 </li><li>交互式shell。默认shell适用于学习&#x2F;验证Python的语法或者局部代码</li><li>IPython交互式shell</li><li>IDE。例如Pycharm、Anaconda等</li></ol>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>First Article</title>
    <link href="/posts/43398/"/>
    <url>/posts/43398/</url>
    
    <content type="html"><![CDATA[<p>Welcome to my blog！This is my first article.</p><p>我其实很早就想搭建一个个人博客，但是由于各种事情一直没能实现。考完研之后这一想法再次涌上心头，于是花了一天时间终于把各种软件的安装和配置给弄完了。下面就将用到一些教程和注意事项贴出。</p><h3 id="创建博客"><a href="#创建博客" class="headerlink" title="创建博客"></a>创建博客</h3><p>我主要是按照这三篇教程一步一步操作的，从Git、nodejs、hexo的安装到将个人博客部署到github。这几篇教程对新手十分友好。</p><p><a href="https://cloud.tencent.com/developer/article/1373210">一文教会你如何搭建个人博客</a><br><a href="https://blog.csdn.net/sparkstark/article/details/124967315">Hexo个人博客安装及配置</a><br><a href="https://blog.csdn.net/guixinchn/article/details/107787660">Hexo博客部署到远程仓库（Conding、Gitee、Github）</a></p><p>第一篇文章中最核心的部分是<strong>将博客部署到远端</strong>（即github），但是按照该文章的步骤会报错。原因是没有配置用户的电子邮件地址和个人名，为此在部署前需要在bash中输入以下命令：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">$ git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.email</span> <span class="hljs-string">&quot;2210749324@qq.com&quot;</span><br>$ git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.name</span> <span class="hljs-string">&quot;Wangfuxun&quot;</span><br></code></pre></td></tr></table></figure><p>–global表示修改用户主目录下的配置信息，如果不含这一项，修改的仅为当前文件夹blog下的_config文件中的配置信息。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol><li><p>在下载Git时，建议下载旧版本，比如2.38.0&#x2F;2.38.1，因为最新版2.39.0有bug，可能无法将博客部署到github（本人已踩过坑）。</p></li><li><p>Git官网下载非常慢，建议直接在镜像网站（比如淘宝）下载。</p></li><li><p>在部署时，遇到了一些问题，其解决方法如下，亲测好用。</p></li></ol><p><a href="https://blog.csdn.net/lvoelife/article/details/127370301">一文解决OpenSSL SSL_read: Connection was reset, errno 10054问题</a><br><a href="https://blog.csdn.net/m0_66695483/article/details/125036055">解决Failed to connect to github.com port 443: Timed out</a></p><ol start="4"><li>为了使文章有唯一的编号，使用了abbrlink插件生成文章链接。需要注意在hexo配置文件_config中修改permalink时需要注意加上末尾的&#x2F;，如果缺失，文章链接会变为下载链接。</li></ol><p><a href="https://blog.csdn.net/m0_51755720/article/details/127996199">Hexo使用Abbrlink插件生成文章固定编号链接</a></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>在写博客时需要使用到markdown语法，非常简单，并且支持HTML标签。<a href="https://www.jianshu.com/p/191d1e21f7ed">Markdown基本语法</a></p><p>为了导入本地图片，需要按照这篇文章的内容进行操作，否则图片无法加载（已踩坑）。<br><a href="https://blog.csdn.net/kantaiyang/article/details/129159055">hexo无法显示本地图片的问题</a></p><p>加载图片格式如下,本地路径使用绝对路径或相对路径均可，例如：E:&#x2F;MyBlog&#x2F;blog&#x2F;source&#x2F;images&#x2F;test.png或者..&#x2F;images&#x2F;test.png。</p><p><code>![图片题注](图片存放路径)</code> </p><p>在Hexo官方文档中对写作&#x2F;生成静态文档&#x2F;配置等内容都有详细的介绍，有需要的话可以查看</p><p><a href="https://hexo.io/docs/">Documentation</a></p><p>以后我会不定期地在博客中更新自己的各种学习笔记。最后作为小白，我会努力向各位优秀的大佬学习，争取成为一个好的程序员，欢迎各位大佬指正不足。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
